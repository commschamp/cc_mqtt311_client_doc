<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommsChampion Ecosystem MQTT v3.1.1 Client: MQTT v3.1.1 Client Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CommsChampion Ecosystem MQTT v3.1.1 Client
   </div>
   <div id="projectbrief">MQTT v3.1.1 Client Library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MQTT v3.1.1 Client Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#doc_cc_mqtt311_client_overview">Overview</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_version">Version of the Library</a></li>
<li class="level1"><a href="#cc_mqtt311_client_header">Header</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_allocation">Client Allocation</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_callbacks">&quot;Must Have&quot; Callbacks Registration</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_callbacks_send_data">Sending Data To Broker</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_callbacks_broker_disconnect">Reporting Unsolicited Broker Disconnection</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_callbacks_message">Reporting Received Message</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_time">Time Measurement</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_log">Error Logging</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_data">Reporting Incoming Data</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_concepts">Operating Concepts</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_connect">Connecting to Broker</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_connect_prepare">Preparing &quot;Connect&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_response_timeout">Configuring &quot;Connect&quot; Response Timeout</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_basic">Configuration of &quot;Connect&quot; Operation</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_will">Will Configuration</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_send">Sending Connection Request</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_cancel">Cancel the &quot;Connect&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_simplify">Simplifying the &quot;Connect&quot; Operation Preparation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_connect_check">Check The Library Remains Connected</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_disconnect">Disconnecting From Broker</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_disconnect_prepare">Preparing &quot;Disconnect&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_disconnect_send">Sending Disconnection Request</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_disconnect_cancel">Cancel the &quot;Disconnect&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_disconnect_simplify">Simplifying the &quot;Disonnect&quot; Operation Preparation.</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_subscribe">Subscribing to Receive Messages</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_prepare">Preparing &quot;Subscribe&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_response_timeout">Configuring &quot;Subscribe&quot; Response Timeout</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_topic">Topic Configuration</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_send">Sending Subscription Request</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_cancel">Cancel the &quot;Subscribe&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_subscribe_simplify">Simplifying the &quot;Subscribe&quot; Operation Preparation.</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_unsubscribe">Unsubscribing from Message Reception</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_prepare">Preparing &quot;Unsubscribe&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_response_timeout">Configuring &quot;Unsubscribe&quot; Response Timeout</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_topic">Topic Configuration</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_send">Sending Unsubscription Request</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_cancel">Cancel the &quot;Unsubscribe&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsubscribe_simplify">Simplifying the &quot;Unsubscribe&quot; Operation Preparation.</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_publish">Publishing Messages</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_publish_prepare">Preparing &quot;Publish&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_response_timeout">Configuring &quot;Publish&quot; Response Timeout</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_resend">Configuring &quot;Publish&quot; Re-Send Attempts</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_basic">Configuration of &quot;Publish&quot; Operation</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_send">Sending Publish Request</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_cancel">Cancel the &quot;Publish&quot; Operation.</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_order">Message Ordering</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_publish_simplify">Simplifying the &quot;Publish&quot; Operation Preparation.</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_receive">Receiving Messages</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a><ul><li class="level2"><a href="#doc_cc_mqtt311_client_unsolicited_disconnect_keep_alive">Keep Alive Timeout</a></li>
<li class="level2"><a href="#doc_cc_mqtt311_client_unsolicited_disconnect_protocol_error">Detecting Protocol Error</a></li>
</ul>
</li>
<li class="level1"><a href="#doc_cc_mqtt311_client_network_disconnect">Network Disconnection</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_thread_safety">Thread Safety</a></li>
<li class="level1"><a href="#doc_cc_mqtt311_client_debug_build">Debug Build</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="doc_cc_mqtt311_client_overview"></a>
Overview</h1>
<p>The <b>MQTT v3.1.1 Client Library</b> from the <a href="https://commschamp.github.io/">CommsChampion Ecosystem</a> provides simple, asynchronous, non-blocking, and easy to use interface to operate MQTT v3.1.1 client. The library doesn't make any assumption on the system it is running on, as well as on the type of I/O link being used to communicate its data to the MQTT v3.1.1 capable broker.</p>
<p>It is a responsibility of the calling application to manage network connectivity as well as measure time required for the correct operation of the MQTT v3.1.1 protocol.</p>
<p>The library allows the application to have a full control over the raw data for any extra analysis and/or manipulation, such as encryption or extra framing.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_version"></a>
Version of the Library</h1>
<p>The version is of the library applicable to this documentation is defined in the <a class="el" href="common_8h.html">cc_mqtt311_client/common.h</a> file using the following defines: </p><ul>
<li><a class="el" href="group__global.html#gad2b118d4ef40fecdd203b8c806bd837c">CC_MQTT311_CLIENT_MAJOR_VERSION</a> </li>
<li><a class="el" href="group__global.html#gadd474bfbdf5c0df054f8a86c56bbb6bc">CC_MQTT311_CLIENT_MINOR_VERSION</a> </li>
<li><a class="el" href="group__global.html#ga793e7ed91c8698c2e7b60557b259effa">CC_MQTT311_CLIENT_PATCH_VERSION</a></li>
</ul>
<h1><a class="anchor" id="cc_mqtt311_client_header"></a>
Header</h1>
<p>To use this <b>MQTT v3.1.1 Client Library</b> use the following single include statement: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cc_mqtt311_client/client.h&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="doc_cc_mqtt311_client_allocation"></a>
Client Allocation</h1>
<p>The library supports multiple independent MQTT v3.1.1 client sessions. The allocation of data structures relevant to a single client is performed using <a class="el" href="group__client.html#ga74efa9fcc585c8d36be00638f15a76ba" title="Allocate new client.">cc_mqtt311_client_alloc()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="group__client.html#gab094fc745d2d398d063d01d121750fc2">CC_Mqtt311ClientHandle</a> client = <a class="code" href="group__client.html#ga74efa9fcc585c8d36be00638f15a76ba">cc_mqtt311_client_alloc</a>();</div>
<div class="ttc" id="agroup__client_html_ga74efa9fcc585c8d36be00638f15a76ba"><div class="ttname"><a href="group__client.html#ga74efa9fcc585c8d36be00638f15a76ba">cc_mqtt311_client_alloc</a></div><div class="ttdeci">CC_Mqtt311ClientHandle cc_mqtt311_client_alloc()</div><div class="ttdoc">Allocate new client.</div></div>
<div class="ttc" id="agroup__client_html_gab094fc745d2d398d063d01d121750fc2"><div class="ttname"><a href="group__client.html#gab094fc745d2d398d063d01d121750fc2">CC_Mqtt311ClientHandle</a></div><div class="ttdeci">CC_Mqtt311Client * CC_Mqtt311ClientHandle</div><div class="ttdoc">Handle used to access client specific data structures.</div><div class="ttdef"><b>Definition:</b> common.h:132</div></div>
</div><!-- fragment --><p> All other functions are client specific, they receive the returned handle as their first parameter.</p>
<p>When work with allocated client is complete, it must be freed using <a class="el" href="group__client.html#gaeb880228cad576589abb1133e53909fb" title="Free previously allocated client.">cc_mqtt311_client_free()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="group__client.html#gaeb880228cad576589abb1133e53909fb">cc_mqtt311_client_free</a>(client);</div>
<div class="ttc" id="agroup__client_html_gaeb880228cad576589abb1133e53909fb"><div class="ttname"><a href="group__client.html#gaeb880228cad576589abb1133e53909fb">cc_mqtt311_client_free</a></div><div class="ttdeci">void cc_mqtt311_client_free(CC_Mqtt311ClientHandle handle)</div><div class="ttdoc">Free previously allocated client.</div></div>
</div><!-- fragment --><p>When working with C++ it is advised to use a smart pointer with a custom deleter. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyDeleter</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CC_Mqtt311Client* ptr)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__client.html#gaeb880228cad576589abb1133e53909fb">::cc_mqtt311_client_free</a>(ptr);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyClientPtr = std::unique_ptr&lt;CC_Mqtt311Client, MyDeleter&gt;;</div>
<div class="line"> </div>
<div class="line">MyClientPtr clientPtr(::<a class="code" href="group__client.html#ga74efa9fcc585c8d36be00638f15a76ba">cc_mqtt311_client_alloc</a>());</div>
<div class="line"><a class="code" href="group__client.html#gab094fc745d2d398d063d01d121750fc2">CC_Mqtt311ClientHandle</a> client = clientPtr.get();</div>
</div><!-- fragment --><p><b>IMPORTANT:</b> The function <b><a class="el" href="group__client.html#gaeb880228cad576589abb1133e53909fb" title="Free previously allocated client.">cc_mqtt311_client_free()</a></b> must <b>NOT</b> be called from within a callback. Use next event loop iteration.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_callbacks"></a>
"Must Have" Callbacks Registration</h1>
<p>In order to properly function the library requires setting several callbacks.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_callbacks_send_data"></a>
Sending Data To Broker</h2>
<p>To client application must assign a callback for the library to be able to send binary data out to the connected broker. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send_data_cb(<span class="keywordtype">void</span>* data, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* send requested buffer to the broker */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a9e18ae5c9d4003f2e376b8ce25a0df15">cc_mqtt311_client_set_send_output_data_callback</a>(client, &amp;my_send_data_cb, data);</div>
<div class="ttc" id="aclient_8h_html_a9e18ae5c9d4003f2e376b8ce25a0df15"><div class="ttname"><a href="client_8h.html#a9e18ae5c9d4003f2e376b8ce25a0df15">cc_mqtt311_client_set_send_output_data_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_send_output_data_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311SendOutputDataCb cb, void *data)</div><div class="ttdoc">Set callback to send raw data over I/O link.</div></div>
</div><!-- fragment --><p> See also the documentation of the <a class="el" href="group__client.html#ga5844e730b238d5e55b7d5df31bdd1228">CC_Mqtt311SendOutputDataCb</a> callback function definition.</p>
<p>In the invoked callback the application is responsible to send the provided data over the I/O link. The application can also perform extra data manipulation like encryption.</p>
<p>The reported data resides in internal data structures of the client library, which can be updated / deleted right after the callback function returns. It means the data may need to be copied into some other buffer, which will be held intact until the send over I/O link operation is complete.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_callbacks_broker_disconnect"></a>
Reporting Unsolicited Broker Disconnection</h2>
<p>The client application must assign a callback for the library to report discovered broker disconnection. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_broker_disconnected_cb(<span class="keywordtype">void</span>* data, <a class="code" href="group__global.html#ga387e5e702bb15bdc7b6aafbfd55237ce">CC_Mqtt311BrokerDisconnectReason</a> reason)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* handle broker disconnection */</span></div>
<div class="line">    <span class="keywordflow">if</span> (info != NULL) {</div>
<div class="line">        ... <span class="comment">/* Access disconnection report details */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a17e182fdb5e1288bff8d64e099c69ccb">cc_mqtt311_client_set_broker_disconnect_report_callback</a>(client, &amp;my_broker_disconnected_cb, data);</div>
<div class="ttc" id="aclient_8h_html_a17e182fdb5e1288bff8d64e099c69ccb"><div class="ttname"><a href="client_8h.html#a17e182fdb5e1288bff8d64e099c69ccb">cc_mqtt311_client_set_broker_disconnect_report_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_broker_disconnect_report_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311BrokerDisconnectReportCb cb, void *data)</div><div class="ttdoc">Set callback to report unsolicited disconnection of the broker.</div></div>
<div class="ttc" id="agroup__global_html_ga387e5e702bb15bdc7b6aafbfd55237ce"><div class="ttname"><a href="group__global.html#ga387e5e702bb15bdc7b6aafbfd55237ce">CC_Mqtt311BrokerDisconnectReason</a></div><div class="ttdeci">CC_Mqtt311BrokerDisconnectReason</div><div class="ttdoc">Reason for reporting unsolicited broker disconnection.</div><div class="ttdef"><b>Definition:</b> common.h:100</div></div>
</div><!-- fragment --><p> See also the documentation of the <a class="el" href="group__client.html#gab469d9395cf35283b34d20170c84f215">CC_Mqtt311BrokerDisconnectReportCb</a> callback function definition.</p>
<p>See also <a class="el" href="index.html#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a> below for details.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_callbacks_message"></a>
Reporting Received Message</h2>
<p>The client application must assign a callback for the library to report application level messages received from the broker. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_message_received_cb(<span class="keywordtype">void</span>* data, <span class="keyword">const</span> <a class="code" href="structCC__Mqtt311MessageInfo.html">CC_Mqtt311MessageInfo</a>* info)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* handle the received message */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a5fa74f1ad844fc0ce1953bf55885eb51">cc_mqtt311_client_set_message_received_report_callback</a>(client, &amp;my_message_received_cb, data);</div>
<div class="ttc" id="aclient_8h_html_a5fa74f1ad844fc0ce1953bf55885eb51"><div class="ttname"><a href="client_8h.html#a5fa74f1ad844fc0ce1953bf55885eb51">cc_mqtt311_client_set_message_received_report_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_message_received_report_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311MessageReceivedReportCb cb, void *data)</div><div class="ttdoc">Set callback to report received message from the broker.</div></div>
<div class="ttc" id="astructCC__Mqtt311MessageInfo_html"><div class="ttname"><a href="structCC__Mqtt311MessageInfo.html">CC_Mqtt311MessageInfo</a></div><div class="ttdoc">Received message information.</div><div class="ttdef"><b>Definition:</b> common.h:245</div></div>
</div><!-- fragment --><p> See also the documentation of the <a class="el" href="group__client.html#ga5ab262b83186330b940cd3ba8fcc0d89">CC_Mqtt311MessageReceivedReportCb</a> callback function definition.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_time"></a>
Time Measurement</h1>
<p>For the correct operation of the MQTT v3.1.1 client side of the protocol, the library requires an ability to measure time. This responsibility is delegated to the application.</p>
<p>The easiest (although not very efficient or very precise) method is to periodically (say every 20ms - 50ms) call the <b><a class="el" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662" title="Notify client about requested time expiry.">cc_mqtt311_client_tick()</a></b> function reporting the amount of elapsed milliseconds: </p><div class="fragment"><div class="line"><a class="code" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662">cc_mqtt311_client_tick</a>(client, 50U);</div>
<div class="ttc" id="agroup__client_html_gaa522f73630cf8af548e9b9e2cb160662"><div class="ttname"><a href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662">cc_mqtt311_client_tick</a></div><div class="ttdeci">void cc_mqtt311_client_tick(CC_Mqtt311ClientHandle handle, unsigned ms)</div><div class="ttdoc">Notify client about requested time expiry.</div></div>
</div><!-- fragment --><p> The library will check if some inner timer has expired and may initiate some response via invocation one of the registered callbacks.</p>
<p>Another (recommended) method is to register a callback so the library may request the time measurement from the application, and when the requested time expires, the application is expected to call the <b><a class="el" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662" title="Notify client about requested time expiry.">cc_mqtt311_client_tick()</a></b> function reporting amount of elapsed milliseconds. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_tick_program_cb(<span class="keywordtype">void</span>* data, <span class="keywordtype">unsigned</span> ms)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">// program appropriate timer</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a2011c73aade75e08c99eda099f51bed5">cc_mqtt311_client_set_next_tick_program_callback</a>(client, &amp;my_tick_program_cb, data);</div>
<div class="ttc" id="aclient_8h_html_a2011c73aade75e08c99eda099f51bed5"><div class="ttname"><a href="client_8h.html#a2011c73aade75e08c99eda099f51bed5">cc_mqtt311_client_set_next_tick_program_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_next_tick_program_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311NextTickProgramCb cb, void *data)</div><div class="ttdoc">Set callback to call when time measurement is required.</div></div>
</div><!-- fragment --><p> It is allowed to invoke the <b><a class="el" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662" title="Notify client about requested time expiry.">cc_mqtt311_client_tick()</a></b> before the actual requested timeout has expired, just make sure that the correct amount of elapsed milliseconds is reported. When the <b><a class="el" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662" title="Notify client about requested time expiry.">cc_mqtt311_client_tick()</a></b> is invoked, it is assumed that the previously requested tick programming has been cancelled and the registered callback requesting to re-program the timer may be invoked again from within the <b><a class="el" href="group__client.html#gaa522f73630cf8af548e9b9e2cb160662" title="Notify client about requested time expiry.">cc_mqtt311_client_tick()</a></b>.</p>
<p>See also the documentation of the <a class="el" href="group__client.html#ga47996219b032988a132103a3e81fc2b0">CC_Mqtt311NextTickProgramCb</a> callback function definition.</p>
<p>In case of callback approach for time measurement is chosen, another callback function (in addition to requesting the new timer programming) to allow interruption of the previously programmed timer must also to be registered. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> my_cancel_tick_program_cb(<span class="keywordtype">void</span>* data)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">return</span> ... <span class="comment">/* return amount of elapsed milliseconds since last tick program */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#abcc672a0aeb085420ba9c97c99192b09">cc_mqtt311_client_set_cancel_next_tick_wait_callback</a>(client, &amp;my_cancel_tick_program_cb, data);</div>
<div class="ttc" id="aclient_8h_html_abcc672a0aeb085420ba9c97c99192b09"><div class="ttname"><a href="client_8h.html#abcc672a0aeb085420ba9c97c99192b09">cc_mqtt311_client_set_cancel_next_tick_wait_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_cancel_next_tick_wait_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311CancelNextTickWaitCb cb, void *data)</div><div class="ttdoc">Set callback to terminate current time measurement.</div></div>
</div><!-- fragment --><p> See also the documentation of the <a class="el" href="group__client.html#ga8abba9e958001b3325dc5d9833cff9d7">CC_Mqtt311CancelNextTickWaitCb</a> callback function definition.</p>
<p>Usually the callbacks of canceling the previously programmed tick and programming a new one will be invoked as a side effect of other events, like report of the incoming data or client requesting to perform one of the available operations.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_log"></a>
Error Logging</h1>
<p>Sometimes the library may exhibit unexpected behaviour, like rejecting some of the parameters. To allow getting extra guidance information of what went wrong it is possible to register optional error logging callback. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_error_log_cb(<span class="keywordtype">void</span>* data, <span class="keyword">const</span> <span class="keywordtype">char</span>* msg)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: %s\n&quot;</span>, msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#aec5b5f687a164a21ea0e898b9b7432de">cc_mqtt311_client_set_error_log_callback</a>(client, &amp;my_error_log_cb, data);</div>
<div class="ttc" id="aclient_8h_html_aec5b5f687a164a21ea0e898b9b7432de"><div class="ttname"><a href="client_8h.html#aec5b5f687a164a21ea0e898b9b7432de">cc_mqtt311_client_set_error_log_callback</a></div><div class="ttdeci">void cc_mqtt311_client_set_error_log_callback(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorLogCb cb, void *data)</div><div class="ttdoc">Set callback to report error messages.</div></div>
</div><!-- fragment --><p> See also the documentation of the <a class="el" href="group__client.html#ga9ccba12b6adb949d4e4a73ad89a991fd">CC_Mqtt311ErrorLogCb</a> callback function definition.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_data"></a>
Reporting Incoming Data</h1>
<p>It is the responsibility of the application to receive data from the broker and report it to the library. The report is performed using the <b><a class="el" href="group__client.html#gaf0832fd9a4a96671fcbb490b6c46a800" title="Provide data (received over I/O link), to the library for processing.">cc_mqtt311_client_process_data()</a></b> function. </p><div class="fragment"><div class="line">uint8_t buf[MAX_BUF_SIZE];</div>
<div class="line">... <span class="comment">// Receive data into buffer</span></div>
<div class="line"><span class="keywordtype">unsigned</span> bufLen = ...; <span class="comment">// Amount of received bytes in the buffer.</span></div>
<div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code" href="group__client.html#gaf0832fd9a4a96671fcbb490b6c46a800">cc_mqtt311_client_process_data</a>(client, buf, bufLen);</div>
<div class="line">... <span class="comment">// Remove the first &quot;consumed&quot; bytes from the buffer and retain the rest</span></div>
<div class="line">    <span class="comment">// until the new data chunk arrives.</span></div>
<div class="ttc" id="agroup__client_html_gaf0832fd9a4a96671fcbb490b6c46a800"><div class="ttname"><a href="group__client.html#gaf0832fd9a4a96671fcbb490b6c46a800">cc_mqtt311_client_process_data</a></div><div class="ttdeci">unsigned cc_mqtt311_client_process_data(CC_Mqtt311ClientHandle handle, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data (received over I/O link), to the library for processing.</div></div>
</div><!-- fragment --><p> The application is responsible to maintain the input buffer. The value returned from the <b><a class="el" href="group__client.html#gaf0832fd9a4a96671fcbb490b6c46a800" title="Provide data (received over I/O link), to the library for processing.">cc_mqtt311_client_process_data()</a></b> function reports amount of consumed bytes. In case not all of the reported bytes were consumed the application is responsible to keep them and report again with new appended data when such arrives.</p>
<p>When new data chunk is reported the library may invoke several callbacks, such as reporting received message, sending new data out, as well as canceling the old and programming new tick timeout.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_concepts"></a>
Operating Concepts</h1>
<p>The library abstracts away multiple MQTT v3.1.1 protocol based "operations". Every such operation has multiple stages: </p><ul>
<li><b>prepare</b> - The operation is "allocated" and relevant handle is returned. </li>
<li><b>configure</b> - Apply one or multiple configurations to the prepared operation. </li>
<li><b>send</b> - Send the configured operation message to the broker.</li>
</ul>
<p>During the <b>send</b> stage the application is expected to provide the callback to report to the application when the operation is complete. One of the parameters of the callback is always "status" of the <a class="el" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a> type. It indicates whether the operation was successfully complete. In addition to the status it reports some extra information reported by the broker. The information from the broker is available <b>if and only if</b> the status is <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>.</p>
<p>The <b>send</b> stage function also returns <a class="el" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> value to indicate whether the <b>send</b> was successfully performed. The provided callback will be invoked <b>if and only if</b> the <b>send</b> returns <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>.</p>
<p>After the <b>send</b> stage the handle returned in the <b>prepare</b> stage can be discarded (no explicit de-allocation is needed / supported) regardless of the return code. After successful <b>send</b> the handle still remains valid until the callback invocation and can be used to <b>cancel</b> the operation. Note that in case the appropriate message has already be <b>sent</b> to the broker, cancelling the outstanding operation can be dangerous. When broker sends a response and client is not expecting it any more, unexpected behaviour (like treating the unexpected message as "protocol error" and disconnecting from the broker) may happen.</p>
<p>In case something went wrong during the <b>configure</b> stage, it is possible to de-allocate the prepared operation using the <b>cancel</b> request. After performing the <b>cancel</b> stage the allocated handle is no longer valid.</p>
<p><b>IMPORTANT LIBRARY LIMITATION</b>: Once an operation is <b>prepared</b>, it must be be immediately <b>configured</b> and <b>sent</b> (or <b>cancelled</b>) before any other other operation can be <b>prepared</b>. For example: </p><div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__connect.html#ga6ece23023427df7f6cad8cc2974cfbd3">CC_Mqtt311ConnectHandle</a> connect = <a class="code" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a">cc_mqtt311_client_connect_prepare</a>(...);</div>
<div class="line">assert(connect != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following attempt to prepare the &quot;subscribe&quot; operation will fail because</span></div>
<div class="line"><span class="comment">// previously allocated &quot;connect&quot; hasn&#39;t been sent or cancelled yet.</span></div>
<div class="line"><a class="code" href="group__subscribe.html#ga8c8f8e1d67f6ce0c5a0e4a21f2d11b97">CC_Mqtt311SubscribeHandle</a> subscribe = <a class="code" href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d">cc_mqtt311_client_subscribe_prepare</a>(...);</div>
<div class="line">assert(subscribe == NULL);</div>
<div class="ttc" id="agroup__connect_html_ga53ad4eae41c73dff94f0b47145fd886a"><div class="ttname"><a href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a">cc_mqtt311_client_connect_prepare</a></div><div class="ttdeci">CC_Mqtt311ConnectHandle cc_mqtt311_client_connect_prepare(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorCode *ec)</div><div class="ttdoc">Prepare &quot;connect&quot; operation.</div></div>
<div class="ttc" id="agroup__connect_html_ga6ece23023427df7f6cad8cc2974cfbd3"><div class="ttname"><a href="group__connect.html#ga6ece23023427df7f6cad8cc2974cfbd3">CC_Mqtt311ConnectHandle</a></div><div class="ttdeci">CC_Mqtt311Connect * CC_Mqtt311ConnectHandle</div><div class="ttdoc">Handle for &quot;connect&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:141</div></div>
<div class="ttc" id="agroup__global_html_ga1313593e8ce828061e8d32ae56c23d4e"><div class="ttname"><a href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a></div><div class="ttdeci">CC_Mqtt311ErrorCode</div><div class="ttdoc">Error code returned by various API functions.</div><div class="ttdef"><b>Definition:</b> common.h:54</div></div>
<div class="ttc" id="agroup__global_html_gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437"><div class="ttname"><a href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a></div><div class="ttdeci">@ CC_Mqtt311ErrorCode_Success</div><div class="ttdoc">The requested function executed successfully.</div><div class="ttdef"><b>Definition:</b> common.h:55</div></div>
<div class="ttc" id="agroup__subscribe_html_ga66977be976fb7fc711b249e0f5b8035d"><div class="ttname"><a href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d">cc_mqtt311_client_subscribe_prepare</a></div><div class="ttdeci">CC_Mqtt311SubscribeHandle cc_mqtt311_client_subscribe_prepare(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorCode *ec)</div><div class="ttdoc">Prepare &quot;subscribe&quot; operation.</div></div>
<div class="ttc" id="agroup__subscribe_html_ga8c8f8e1d67f6ce0c5a0e4a21f2d11b97"><div class="ttname"><a href="group__subscribe.html#ga8c8f8e1d67f6ce0c5a0e4a21f2d11b97">CC_Mqtt311SubscribeHandle</a></div><div class="ttdeci">CC_Mqtt311Subscribe * CC_Mqtt311SubscribeHandle</div><div class="ttdoc">Handle for &quot;subscribe&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:159</div></div>
</div><!-- fragment --><h1><a class="anchor" id="doc_cc_mqtt311_client_response_timeout"></a>
Default Response Timeout</h1>
<p>After sending any operation request to the broker, the client library has to allow some time for the broker to process the request. If it takes too much time, the client must report that operation has failed via the set callback. By default the client library allows 2 seconds for such response to arrive. Changing this default value is possible using the <b><a class="el" href="group__client.html#gaa756d659563c17e124ea6006a69139da" title="Configure default response timeout period.">cc_mqtt311_client_set_default_response_timeout()</a></b> function, and retrieving of the currently configured value can be done using the <b><a class="el" href="group__client.html#ga6848272b052281dcd51fa01049bbc667" title="Retrieved currently configured default response timeout period.">cc_mqtt311_client_get_default_response_timeout()</a></b> function. </p><div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__client.html#gaa756d659563c17e124ea6006a69139da">cc_mqtt311_client_set_default_response_timeout</a>(client, 3000 <span class="comment">/* in ms */</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__client_html_gaa756d659563c17e124ea6006a69139da"><div class="ttname"><a href="group__client.html#gaa756d659563c17e124ea6006a69139da">cc_mqtt311_client_set_default_response_timeout</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_set_default_response_timeout(CC_Mqtt311ClientHandle handle, unsigned ms)</div><div class="ttdoc">Configure default response timeout period.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="doc_cc_mqtt311_client_connect"></a>
Connecting to Broker</h1>
<p>To connect to broker use <a class="el" href="group__connect.html">connect</a> operation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_prepare"></a>
Preparing "Connect" Operation.</h2>
<div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__connect.html#ga6ece23023427df7f6cad8cc2974cfbd3">CC_Mqtt311ConnectHandle</a> connect = <a class="code" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a">cc_mqtt311_client_connect_prepare</a>(client, &amp;ec);</div>
<div class="line"><span class="keywordflow">if</span> (connect == NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Connect allocation failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b> that the <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b> cannot be called from within a callback. For example, if the broker disconnection is reported via <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">callback</a> then the <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b> cannot be invoked right away. It needs to be postponed until the next event loop iteration.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_response_timeout"></a>
Configuring "Connect" Response Timeout</h2>
<p>When created, the "connect" operation inherits the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a> configuration. It can be changed for the allocated operation using the <b><a class="el" href="group__connect.html#ga74df6bdc9c742003c74e94b8af102e0c" title="Configure the broker response timeout for the &quot;connect&quot; operation.">cc_mqtt311_client_connect_set_response_timeout()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__connect.html#ga74df6bdc9c742003c74e94b8af102e0c">cc_mqtt311_client_connect_set_response_timeout</a>(connect, 1000);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga74df6bdc9c742003c74e94b8af102e0c"><div class="ttname"><a href="group__connect.html#ga74df6bdc9c742003c74e94b8af102e0c">cc_mqtt311_client_connect_set_response_timeout</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect_set_response_timeout(CC_Mqtt311ConnectHandle handle, unsigned ms)</div><div class="ttdoc">Configure the broker response timeout for the &quot;connect&quot; operation.</div></div>
</div><!-- fragment --><p> To retrieve the configured response timeout use the <b><a class="el" href="group__connect.html#ga7e234f55d89b4c2a2c25c1826ebd2d28" title="Retrieve the configured the broker response timeout for the &quot;connect&quot; operation.">cc_mqtt311_client_connect_get_response_timeout()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_basic"></a>
Configuration of "Connect" Operation</h2>
<p>To configure "connect" operation use <b><a class="el" href="group__connect.html#gad84a395dd590d67671bfee7250b67d06" title="Perform basic configuration of the &quot;connect&quot; operation.">cc_mqtt311_client_connect_config()</a></b> function. </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311ConnectConfig.html">CC_Mqtt311ConnectConfig</a> config;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the &quot;config&quot;</span></div>
<div class="line"><a class="code" href="group__connect.html#ga7313c201b35d73d585112f2026f658b4">cc_mqtt311_client_connect_init_config</a>(&amp;config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update the values if needed:</span></div>
<div class="line">config.<a class="code" href="structCC__Mqtt311ConnectConfig.html#ae305fcb58d773e611a6cea92eb682d70">m_clientId</a> = <span class="stringliteral">&quot;some_client&quot;</span>;</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311ConnectConfig.html#a56b1d00587a8a6900fe2a97295d8926d">m_cleanSession</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform the configuration</span></div>
<div class="line">ec = <a class="code" href="group__connect.html#gad84a395dd590d67671bfee7250b67d06">cc_mqtt311_client_connect_config</a>(connect, &amp;config);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Basic configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga7313c201b35d73d585112f2026f658b4"><div class="ttname"><a href="group__connect.html#ga7313c201b35d73d585112f2026f658b4">cc_mqtt311_client_connect_init_config</a></div><div class="ttdeci">void cc_mqtt311_client_connect_init_config(CC_Mqtt311ConnectConfig *config)</div><div class="ttdoc">Intialize the CC_Mqtt311ConnectConfig configuration structure.</div></div>
<div class="ttc" id="agroup__connect_html_gad84a395dd590d67671bfee7250b67d06"><div class="ttname"><a href="group__connect.html#gad84a395dd590d67671bfee7250b67d06">cc_mqtt311_client_connect_config</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect_config(CC_Mqtt311ConnectHandle handle, const CC_Mqtt311ConnectConfig *config)</div><div class="ttdoc">Perform basic configuration of the &quot;connect&quot; operation.</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectConfig_html"><div class="ttname"><a href="structCC__Mqtt311ConnectConfig.html">CC_Mqtt311ConnectConfig</a></div><div class="ttdoc">Configuration structure to be passed to the cc_mqtt311_client_connect_config().</div><div class="ttdef"><b>Definition:</b> common.h:188</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectConfig_html_a56b1d00587a8a6900fe2a97295d8926d"><div class="ttname"><a href="structCC__Mqtt311ConnectConfig.html#a56b1d00587a8a6900fe2a97295d8926d">CC_Mqtt311ConnectConfig::m_cleanSession</a></div><div class="ttdeci">bool m_cleanSession</div><div class="ttdoc">Clean session flag, defaults to false.</div><div class="ttdef"><b>Definition:</b> common.h:194</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectConfig_html_ae305fcb58d773e611a6cea92eb682d70"><div class="ttname"><a href="structCC__Mqtt311ConnectConfig.html#ae305fcb58d773e611a6cea92eb682d70">CC_Mqtt311ConnectConfig::m_clientId</a></div><div class="ttdeci">const char * m_clientId</div><div class="ttdoc">Zero terminated Client ID string, can be NULL. When NULL means empty &quot;Client ID&quot;. Defaults to NULL.</div><div class="ttdef"><b>Definition:</b> common.h:189</div></div>
</div><!-- fragment --><p><b>IMPORTANT</b>: MQTT v3.1.1 specification allows reconnection to the broker while requesting previous session restoration (via "clean session" bit). By default, the client library verifies that the message received from the broker was actually subscribed to before reporting the message to the application (see <a class="el" href="index.html#doc_cc_mqtt311_client_receive">Receiving Messages</a> for details). To prevent potential errors of the client and broker inner states being out of sync, the <b>first</b> "connect" operation requires setting the <a class="el" href="structCC__Mqtt311ConnectConfig.html#a56b1d00587a8a6900fe2a97295d8926d">CC_Mqtt311ConnectConfig::m_cleanSession</a> value to <b>true</b>. The only exception to this rule is when the subscription verification on message reception was disabled (described in the <a class="el" href="index.html#doc_cc_mqtt311_client_receive">Receiving Messages</a> section below). In case the subscription verification is still enabled and the <a class="el" href="structCC__Mqtt311ConnectConfig.html#a56b1d00587a8a6900fe2a97295d8926d">CC_Mqtt311ConnectConfig::m_cleanSession</a> value is <b>NOT</b> set to <b>true</b>, the function rejects the configuration with the <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea081e0b0df5750c4216eccfdd5dbbec7b">CC_Mqtt311ErrorCode_BadParam</a> error code. Any subsequent reconnection attempts will allow setting the value to <b>false</b>.</p>
<p>See also documentation of the <a class="el" href="structCC__Mqtt311ConnectConfig.html">CC_Mqtt311ConnectConfig</a> structure.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_will"></a>
Will Configuration</h2>
<p>To perform will configuration use the <b><a class="el" href="group__connect.html#ga7ff969e033bf208cd3b22c968961602b" title="Perform will configuration of the &quot;connect&quot; operation.">cc_mqtt311_client_connect_config_will()</a></b> function. </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311ConnectWillConfig.html">CC_Mqtt311ConnectWillConfig</a> willConfig;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__connect.html#ga94621e08d696720fcaa7db48538b4ee7">cc_mqtt311_client_connect_init_config_will</a>(&amp;willConfig);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values if needed</span></div>
<div class="line">willConfig.<a class="code" href="structCC__Mqtt311ConnectWillConfig.html#ae16eb95d9e3b6ffbc7af22a52ce9484d">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line">willConfig.<a class="code" href="structCC__Mqtt311ConnectWillConfig.html#a21738c541de892a8e70eb8444c54e1af">m_data</a> = ...;</div>
<div class="line">willConfig.<a class="code" href="structCC__Mqtt311ConnectWillConfig.html#a49c22147904cf75c4d8466e2bc2a4577">m_dataLen</a> = ...;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform the configuration</span></div>
<div class="line">ec = <a class="code" href="group__connect.html#ga7ff969e033bf208cd3b22c968961602b">cc_mqtt311_client_connect_config_will</a>(connect, &amp;willConfig);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Will configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga7ff969e033bf208cd3b22c968961602b"><div class="ttname"><a href="group__connect.html#ga7ff969e033bf208cd3b22c968961602b">cc_mqtt311_client_connect_config_will</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect_config_will(CC_Mqtt311ConnectHandle handle, const CC_Mqtt311ConnectWillConfig *config)</div><div class="ttdoc">Perform will configuration of the &quot;connect&quot; operation.</div></div>
<div class="ttc" id="agroup__connect_html_ga94621e08d696720fcaa7db48538b4ee7"><div class="ttname"><a href="group__connect.html#ga94621e08d696720fcaa7db48538b4ee7">cc_mqtt311_client_connect_init_config_will</a></div><div class="ttdeci">void cc_mqtt311_client_connect_init_config_will(CC_Mqtt311ConnectWillConfig *config)</div><div class="ttdoc">Intialize the CC_Mqtt311ConnectWillConfig configuration structure.</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectWillConfig_html"><div class="ttname"><a href="structCC__Mqtt311ConnectWillConfig.html">CC_Mqtt311ConnectWillConfig</a></div><div class="ttdoc">Configuration structure to be passed to the cc_mqtt311_client_connect_config_will().</div><div class="ttdef"><b>Definition:</b> common.h:201</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectWillConfig_html_a21738c541de892a8e70eb8444c54e1af"><div class="ttname"><a href="structCC__Mqtt311ConnectWillConfig.html#a21738c541de892a8e70eb8444c54e1af">CC_Mqtt311ConnectWillConfig::m_data</a></div><div class="ttdeci">const unsigned char * m_data</div><div class="ttdoc">Will message data, can be NULL. Defaults to NULL.</div><div class="ttdef"><b>Definition:</b> common.h:203</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectWillConfig_html_a49c22147904cf75c4d8466e2bc2a4577"><div class="ttname"><a href="structCC__Mqtt311ConnectWillConfig.html#a49c22147904cf75c4d8466e2bc2a4577">CC_Mqtt311ConnectWillConfig::m_dataLen</a></div><div class="ttdeci">unsigned m_dataLen</div><div class="ttdoc">Number of will data bytes. When 0 means no data. Defaults to 0.</div><div class="ttdef"><b>Definition:</b> common.h:204</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectWillConfig_html_ae16eb95d9e3b6ffbc7af22a52ce9484d"><div class="ttname"><a href="structCC__Mqtt311ConnectWillConfig.html#ae16eb95d9e3b6ffbc7af22a52ce9484d">CC_Mqtt311ConnectWillConfig::m_topic</a></div><div class="ttdeci">const char * m_topic</div><div class="ttdoc">Will topic string, must NOT be NULL or empty. Defaults to NULL.</div><div class="ttdef"><b>Definition:</b> common.h:202</div></div>
</div><!-- fragment --><p> See also documentation of the <a class="el" href="structCC__Mqtt311ConnectWillConfig.html">CC_Mqtt311ConnectWillConfig</a> structure.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_send"></a>
Sending Connection Request</h2>
<p>When all the necessary configurations are performed for the allocated "connect" operation it can actually be sent to the broker. To initiate sending use the <b><a class="el" href="group__connect.html#ga8946d397e9eafbe7c962b34061d5c07b" title="Send the configured &quot;connect&quot; operation to broker.">cc_mqtt311_client_connect_send()</a></b> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_connect_complete_cb(<span class="keywordtype">void</span>* data, <a class="code" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a> status, <span class="keyword">const</span> <a class="code" href="structCC__Mqtt311ConnectResponse.html">CC_Mqtt311ConnectResponse</a>* response)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ERROR: The connection operation has failed with status=%d\n&quot;</span>, status);</div>
<div class="line">        ... <span class="comment">// handle error.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;response&quot; is not NULL when status is CC_Mqtt311AsyncOpStatus_Complete.</span></div>
<div class="line">    assert(response != NULL);</div>
<div class="line">    ... <span class="comment">// Analyze response values.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__connect.html#ga8946d397e9eafbe7c962b34061d5c07b">cc_mqtt311_client_connect_send</a>(connect, &amp;my_connect_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send connect request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga8946d397e9eafbe7c962b34061d5c07b"><div class="ttname"><a href="group__connect.html#ga8946d397e9eafbe7c962b34061d5c07b">cc_mqtt311_client_connect_send</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect_send(CC_Mqtt311ConnectHandle handle, CC_Mqtt311ConnectCompleteCb cb, void *cbData)</div><div class="ttdoc">Send the configured &quot;connect&quot; operation to broker.</div></div>
<div class="ttc" id="agroup__global_html_gaf6bdf774d2591a042326994e6b10c7bd"><div class="ttname"><a href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a></div><div class="ttdeci">CC_Mqtt311AsyncOpStatus</div><div class="ttdoc">Status of the asynchronous operation.</div><div class="ttdef"><b>Definition:</b> common.h:76</div></div>
<div class="ttc" id="agroup__global_html_ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a"><div class="ttname"><a href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a></div><div class="ttdeci">@ CC_Mqtt311AsyncOpStatus_Complete</div><div class="ttdoc">The requested operation has been completed, refer to reported extra details for information.</div><div class="ttdef"><b>Definition:</b> common.h:77</div></div>
<div class="ttc" id="astructCC__Mqtt311ConnectResponse_html"><div class="ttname"><a href="structCC__Mqtt311ConnectResponse.html">CC_Mqtt311ConnectResponse</a></div><div class="ttdoc">Response information from broker to &quot;connect&quot; request.</div><div class="ttdef"><b>Definition:</b> common.h:212</div></div>
</div><!-- fragment --><p> The provided callback will be invoked when the "connect" operation is complete <b> if and only if</b> the function returns <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>.</p>
<p>The handle returned by the <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b> function can be discarded (there is no free / de-allocation) right after the <b><a class="el" href="group__connect.html#ga8946d397e9eafbe7c962b34061d5c07b" title="Send the configured &quot;connect&quot; operation to broker.">cc_mqtt311_client_connect_send()</a></b> invocation regardless of the returned error code. However, the handle remains valid until the callback is called (in case the <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a> was returned). The valid handle can be used to <a class="el" href="index.html#doc_cc_mqtt311_client_connect_cancel">cancel</a> the operation before the completion callback is invoked.</p>
<p>When the "connect" operation completion callback is invoked the reported "response" information is present <b>if and only if</b> the "status" is <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>.</p>
<p><b>NOTE</b> that only single "connect" operation is allowed at a time, any attempt to prepare a new one via <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b> will be rejected until the "connect" operation completion callback is invoked or the operation is <a class="el" href="index.html#doc_cc_mqtt311_client_connect_cancel">cancelled</a>.</p>
<p>Quote from the MQTT v3.1.1 specification: </p><div class="fragment"><div class="line">If a server sends a CONNACK packet containing a non-zero return code it MUST</div>
<div class="line">then close the Network Connection [MQTT-3.2.2-5].</div>
</div><!-- fragment --><p> When the callback reporting the connection status is invoked, it is responsibility of the application to check the <a class="el" href="structCC__Mqtt311ConnectResponse.html#ad4bca99b9a6b1846c4af88bb3a80ca61">CC_Mqtt311ConnectResponse::m_returnCode</a> value. If it's not <a class="el" href="group__connect.html#gga65ee2216b444cf26e58cbb0dc50feef2ae7c7f4afb7101495d640b9bc5d14d743">CC_Mqtt311ConnectReturnCode_Accepted</a>, the application is responsible to close the network connection and retry the "connect" operation after the network connection to the broker is re-established. The same should be done when the "connect" operation is not properly completed, i.e. the reported status is <b>NOT</b> <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_cancel"></a>
Cancel the "Connect" Operation.</h2>
<p>While the handle returned by the <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b> is still valid it is possible to cancel / discard the operation. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__connect.html#ga9563e04808684f032a741a074b728413">cc_mqtt311_client_connect_cancel</a>(connect);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to cancel connect with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga9563e04808684f032a741a074b728413"><div class="ttname"><a href="group__connect.html#ga9563e04808684f032a741a074b728413">cc_mqtt311_client_connect_cancel</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect_cancel(CC_Mqtt311ConnectHandle handle)</div><div class="ttdoc">Cancel the allocated &quot;connect&quot; operation.</div></div>
</div><!-- fragment --><p> In case the <b><a class="el" href="group__connect.html#ga8946d397e9eafbe7c962b34061d5c07b" title="Send the configured &quot;connect&quot; operation to broker.">cc_mqtt311_client_connect_send()</a></b> function was successfully called before the <b><a class="el" href="group__connect.html#ga9563e04808684f032a741a074b728413" title="Cancel the allocated &quot;connect&quot; operation.">cc_mqtt311_client_connect_cancel()</a></b>, the operation is cancelled <b>without</b> callback invocation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_simplify"></a>
Simplifying the "Connect" Operation Preparation.</h2>
<p>In many use cases the "connect" operation can be quite simple with a lot of defaults. To simplify the sequence of the operation preparation and handling of errors, the library provides wrapper function(s) that can be used: </p><ul>
<li><b><a class="el" href="group__connect.html#ga7b6710338078461783590b1c23b312e5" title="Prepare, configure, and send &quot;connect&quot; request in one go.">cc_mqtt311_client_connect()</a></b> </li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311ConnectConfig.html">CC_Mqtt311ConnectConfig</a> config;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the &quot;config&quot;</span></div>
<div class="line"><a class="code" href="group__connect.html#ga7313c201b35d73d585112f2026f658b4">cc_mqtt311_client_connect_init_config</a>(&amp;config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update the values if needed:</span></div>
<div class="line">config.<a class="code" href="structCC__Mqtt311ConnectConfig.html#ae305fcb58d773e611a6cea92eb682d70">m_clientId</a> = <span class="stringliteral">&quot;some_client&quot;</span>;</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311ConnectConfig.html#a56b1d00587a8a6900fe2a97295d8926d">m_cleanSession</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__connect.html#ga7b6710338078461783590b1c23b312e5">cc_mqtt311_client_connect</a>(client, config, <span class="keyword">null</span>, &amp;my_connect_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send connect request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connect_html_ga7b6710338078461783590b1c23b312e5"><div class="ttname"><a href="group__connect.html#ga7b6710338078461783590b1c23b312e5">cc_mqtt311_client_connect</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_connect(CC_Mqtt311ClientHandle handle, const CC_Mqtt311ConnectConfig *config, const CC_Mqtt311ConnectWillConfig *willConfig, CC_Mqtt311ConnectCompleteCb cb, void *cbData)</div><div class="ttdoc">Prepare, configure, and send &quot;connect&quot; request in one go.</div></div>
</div><!-- fragment --><p> Note that the wrapper function does NOT expose the handle returned by the <b><a class="el" href="group__connect.html#ga53ad4eae41c73dff94f0b47145fd886a" title="Prepare &quot;connect&quot; operation.">cc_mqtt311_client_connect_prepare()</a></b>. It means that it's not possible to cancel the "connect" operation before its completion.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_connect_check"></a>
Check The Library Remains Connected</h2>
<p>At any time it is possible to check the internal state of the library of whether it's properly connected to the broker. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isConnected = <a class="code" href="group__connect.html#gae1967cc34475ffae4a78eb3887387f6e">cc_mqtt311_client_is_connected</a>(client);</div>
<div class="ttc" id="agroup__connect_html_gae1967cc34475ffae4a78eb3887387f6e"><div class="ttname"><a href="group__connect.html#gae1967cc34475ffae4a78eb3887387f6e">cc_mqtt311_client_is_connected</a></div><div class="ttdeci">bool cc_mqtt311_client_is_connected(CC_Mqtt311ClientHandle handle)</div><div class="ttdoc">Check the inner state of the library of whether it's connected to the broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="doc_cc_mqtt311_client_disconnect"></a>
Disconnecting From Broker</h1>
<p>To intentionally disconnect from broker use <a class="el" href="group__disconnect.html">disconnect</a> operation. The unsolicited disconnection from the broker is described in ref <a class="el" href="index.html#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a> section below.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_disconnect_prepare"></a>
Preparing "Disconnect" Operation.</h2>
<div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__disconnect.html#ga59696246dd2e585ff34cb7858d49160a">CC_Mqtt311DisconnectHandle</a> disconnect = <a class="code" href="group__disconnect.html#ga5427b7da69556916ec96f1c09e6cc62b">cc_mqtt311_client_disconnect_prepare</a>(client, &amp;ec);</div>
<div class="line"><span class="keywordflow">if</span> (disconnect == NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Disconnect allocation failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__disconnect_html_ga5427b7da69556916ec96f1c09e6cc62b"><div class="ttname"><a href="group__disconnect.html#ga5427b7da69556916ec96f1c09e6cc62b">cc_mqtt311_client_disconnect_prepare</a></div><div class="ttdeci">CC_Mqtt311DisconnectHandle cc_mqtt311_client_disconnect_prepare(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorCode *ec)</div><div class="ttdoc">Prepare &quot;disconnect&quot; operation.</div></div>
<div class="ttc" id="agroup__disconnect_html_ga59696246dd2e585ff34cb7858d49160a"><div class="ttname"><a href="group__disconnect.html#ga59696246dd2e585ff34cb7858d49160a">CC_Mqtt311DisconnectHandle</a></div><div class="ttdeci">CC_Mqtt311Disconnect * CC_Mqtt311DisconnectHandle</div><div class="ttdoc">Handle for &quot;disconnect&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:150</div></div>
</div><!-- fragment --><h2><a class="anchor" id="doc_cc_mqtt311_client_disconnect_send"></a>
Sending Disconnection Request</h2>
<p>When the necessary configuration is performed for the allocated "disconnect" operation it can be sent to the broker. To initiate sending use the <b><a class="el" href="group__disconnect.html#ga587b05582bc06f12090127cb8de37663" title="Send the configured &quot;disconnect&quot; operation to broker.">cc_mqtt311_client_disconnect_send()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__disconnect.html#ga587b05582bc06f12090127cb8de37663">cc_mqtt311_client_disconnect_send</a>(disconnect);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send disconnect request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line">assert(!<a class="code" href="group__connect.html#gae1967cc34475ffae4a78eb3887387f6e">cc_mqtt311_client_is_connected</a>(client)); <span class="comment">// Expect immediate disconnection after the successful send</span></div>
<div class="ttc" id="agroup__disconnect_html_ga587b05582bc06f12090127cb8de37663"><div class="ttname"><a href="group__disconnect.html#ga587b05582bc06f12090127cb8de37663">cc_mqtt311_client_disconnect_send</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_disconnect_send(CC_Mqtt311DisconnectHandle handle)</div><div class="ttdoc">Send the configured &quot;disconnect&quot; operation to broker.</div></div>
</div><!-- fragment --><p> <b>NOTE</b> that the <b><a class="el" href="group__disconnect.html#ga587b05582bc06f12090127cb8de37663" title="Send the configured &quot;disconnect&quot; operation to broker.">cc_mqtt311_client_disconnect_send()</a></b> function doesn't receive any callback because there is no expected response to the <b>DISCONNECT</b> message from the broker. The disconnection effect is immediate. The application is expected to terminate the network connection (while making sure that the the requested data is actually sent). The handle returned by the <b><a class="el" href="group__disconnect.html#ga5427b7da69556916ec96f1c09e6cc62b" title="Prepare &quot;disconnect&quot; operation.">cc_mqtt311_client_disconnect_prepare()</a></b> must be discarded.</p>
<p>In case there are other asynchronous operations that hasn't been completed yet, their completion callback is automatically invoked with <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bdaaab67da08f6f6f2a874fdd2622988816">CC_Mqtt311AsyncOpStatus_Aborted</a> status.</p>
<p><b>IMPORTANT:</b> In case of sending the explicit disconnection request the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">registered unsolicited disconnection callback</a> is <b>NOT</b> invoked.</p>
<p>After the disconnection the application can re-establish network connection to the broker and perform the <a class="el" href="index.html#doc_cc_mqtt311_client_connect">connect</a> operation again.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_disconnect_cancel"></a>
Cancel the "Disconnect" Operation.</h2>
<p>While the handle returned by the <b><a class="el" href="group__disconnect.html#ga5427b7da69556916ec96f1c09e6cc62b" title="Prepare &quot;disconnect&quot; operation.">cc_mqtt311_client_disconnect_prepare()</a></b> is still valid it is possible to cancel / discard the operation. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__disconnect.html#ga5a99a08572461b7d058c7bf366be7b7e">cc_mqtt311_client_disconnect_cancel</a>(disconnect);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to cancel disconnect with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__disconnect_html_ga5a99a08572461b7d058c7bf366be7b7e"><div class="ttname"><a href="group__disconnect.html#ga5a99a08572461b7d058c7bf366be7b7e">cc_mqtt311_client_disconnect_cancel</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_disconnect_cancel(CC_Mqtt311DisconnectHandle handle)</div><div class="ttdoc">Cancel the allocated &quot;disconnect&quot; operation.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="doc_cc_mqtt311_client_disconnect_simplify"></a>
Simplifying the "Disonnect" Operation Preparation.</h2>
<p>In many use cases the "disconnect" operation can be quite simple. To simplify the sequence of the operation preparation and handling of errors, the library provides wrapper function(s) that can be used: </p><ul>
<li><b><a class="el" href="group__disconnect.html#ga83e2b6f1cb824bb9113a8a94fecd1b59" title="Prepare, and send &quot;disconnect&quot; request in one go.">cc_mqtt311_client_disconnect()</a></b> </li>
</ul>
<p>For example: </p><div class="fragment"><div class="line">ec = <a class="code" href="group__disconnect.html#ga83e2b6f1cb824bb9113a8a94fecd1b59">cc_mqtt311_client_disconnect</a>(client);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send disconnect request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__disconnect_html_ga83e2b6f1cb824bb9113a8a94fecd1b59"><div class="ttname"><a href="group__disconnect.html#ga83e2b6f1cb824bb9113a8a94fecd1b59">cc_mqtt311_client_disconnect</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_disconnect(CC_Mqtt311ClientHandle handle)</div><div class="ttdoc">Prepare, and send &quot;disconnect&quot; request in one go.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="doc_cc_mqtt311_client_subscribe"></a>
Subscribing to Receive Messages</h1>
<p>To subscribe to receive incoming messages use <a class="el" href="group__subscribe.html">subscribe</a> operation. The application can issue multiple "subscribe" operations in parallel.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_prepare"></a>
Preparing "Subscribe" Operation.</h2>
<div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__subscribe.html#ga8c8f8e1d67f6ce0c5a0e4a21f2d11b97">CC_Mqtt311SubscribeHandle</a> subscribe = <a class="code" href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d">cc_mqtt311_client_subscribe_prepare</a>(client, &amp;ec);</div>
<div class="line"><span class="keywordflow">if</span> (subscribe == NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Subscribe allocation failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_response_timeout"></a>
Configuring "Subscribe" Response Timeout</h2>
<p>When created, the "subscribe" operation inherits the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a> configuration. It can be changed for the allocated operation using the <b><a class="el" href="group__subscribe.html#ga15cc63c97f1ab0f14903c407c66e2553" title="Configure the broker response timeout for the &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_set_response_timeout()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__subscribe.html#ga15cc63c97f1ab0f14903c407c66e2553">cc_mqtt311_client_subscribe_set_response_timeout</a>(subscribe, 1000);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__subscribe_html_ga15cc63c97f1ab0f14903c407c66e2553"><div class="ttname"><a href="group__subscribe.html#ga15cc63c97f1ab0f14903c407c66e2553">cc_mqtt311_client_subscribe_set_response_timeout</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_subscribe_set_response_timeout(CC_Mqtt311SubscribeHandle handle, unsigned ms)</div><div class="ttdoc">Configure the broker response timeout for the &quot;subscribe&quot; operation.</div></div>
</div><!-- fragment --><p> To retrieve the configured response timeout use the <b><a class="el" href="group__subscribe.html#ga4d45aba52e2e0068dcc12778885037b0" title="Retrieve the configured the broker response timeout for the &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_get_response_timeout()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_topic"></a>
Topic Configuration</h2>
<p>Single <b>SUBSCRIBE</b> message can carry multiple topic subscriptions. Use separate <b><a class="el" href="group__subscribe.html#ga9d0b4d6a0a0358eabdef5083488bb245" title="Add topic configuration of the &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_config_topic()</a></b> function invocation to configure each such subscription. </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311SubscribeTopicConfig.html">CC_Mqtt311SubscribeTopicConfig</a> topicConfig;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__subscribe.html#gad0fa342ea2d809b317b805ffa90f675e">cc_mqtt311_client_subscribe_init_config_topic</a>(&amp;topicConfig);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values if needed</span></div>
<div class="line">topicConfig.<a class="code" href="structCC__Mqtt311SubscribeTopicConfig.html#abdb3eb5f4d614cfa813262c0cd59e004">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform the configuration</span></div>
<div class="line">ec = <a class="code" href="group__subscribe.html#ga9d0b4d6a0a0358eabdef5083488bb245">cc_mqtt311_client_subscribe_config_topic</a>(subscribe, &amp;topicConfig);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Topic configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__subscribe_html_ga9d0b4d6a0a0358eabdef5083488bb245"><div class="ttname"><a href="group__subscribe.html#ga9d0b4d6a0a0358eabdef5083488bb245">cc_mqtt311_client_subscribe_config_topic</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_subscribe_config_topic(CC_Mqtt311SubscribeHandle handle, const CC_Mqtt311SubscribeTopicConfig *config)</div><div class="ttdoc">Add topic configuration of the &quot;subscribe&quot; operation.</div></div>
<div class="ttc" id="agroup__subscribe_html_gad0fa342ea2d809b317b805ffa90f675e"><div class="ttname"><a href="group__subscribe.html#gad0fa342ea2d809b317b805ffa90f675e">cc_mqtt311_client_subscribe_init_config_topic</a></div><div class="ttdeci">void cc_mqtt311_client_subscribe_init_config_topic(CC_Mqtt311SubscribeTopicConfig *config)</div><div class="ttdoc">Intialize the CC_Mqtt311SubscribeTopicConfig configuration structure.</div></div>
<div class="ttc" id="astructCC__Mqtt311SubscribeTopicConfig_html"><div class="ttname"><a href="structCC__Mqtt311SubscribeTopicConfig.html">CC_Mqtt311SubscribeTopicConfig</a></div><div class="ttdoc">Topic filter configuration structure of the &quot;subscribe&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:221</div></div>
<div class="ttc" id="astructCC__Mqtt311SubscribeTopicConfig_html_abdb3eb5f4d614cfa813262c0cd59e004"><div class="ttname"><a href="structCC__Mqtt311SubscribeTopicConfig.html#abdb3eb5f4d614cfa813262c0cd59e004">CC_Mqtt311SubscribeTopicConfig::m_topic</a></div><div class="ttdeci">const char * m_topic</div><div class="ttdoc">&quot;Topic Filter&quot; string, mustn't be NULL</div><div class="ttdef"><b>Definition:</b> common.h:222</div></div>
</div><!-- fragment --><p> See also documentation of the <a class="el" href="structCC__Mqtt311SubscribeTopicConfig.html">CC_Mqtt311SubscribeTopicConfig</a> structure.</p>
<p>By default the library will perform the analysis of the submitted topic format and reject it if topic format is incorrect. However, for performance reasons it is possible to disable such verification when client application ensures that no invalid topics are used. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__client.html#ga5860ac24216d0adb966db2367ae31690">cc_mqtt311_client_set_verify_outgoing_topic_enabled</a>(client, <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something is wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__client_html_ga5860ac24216d0adb966db2367ae31690"><div class="ttname"><a href="group__client.html#ga5860ac24216d0adb966db2367ae31690">cc_mqtt311_client_set_verify_outgoing_topic_enabled</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_set_verify_outgoing_topic_enabled(CC_Mqtt311ClientHandle handle, bool enabled)</div><div class="ttdoc">Control outgoing topic format verification.</div></div>
</div><!-- fragment --><p> <b>NOTE</b> that the configuration is global per client and not per "subscribe" operation.</p>
<p>Also <b>note</b> that the same function controls the verification of the "subscribe", "unsubscribe" and "publish" topic formats.</p>
<p>To retrieve the current configuration use <b><a class="el" href="group__client.html#gae0f7745560288d4c6e5dc948289d8a85" title="Retrieve current outgoing topic format verification control.">cc_mqtt311_client_get_verify_outgoing_topic_enabled()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_send"></a>
Sending Subscription Request</h2>
<p>When all the necessary configurations are performed for the allocated "subscribe" operation it can actually be sent to the broker. To initiate sending use the <b><a class="el" href="group__subscribe.html#gaf20fda15c5c5d1f334f285a9c432cfd1" title="Send the configured &quot;subscribe&quot; operation to broker.">cc_mqtt311_client_subscribe_send()</a></b> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_subscribe_complete_cb(<span class="keywordtype">void</span>* data, <a class="code" href="group__subscribe.html#ga8c8f8e1d67f6ce0c5a0e4a21f2d11b97">CC_Mqtt311SubscribeHandle</a> handle, <a class="code" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a> status, <span class="keyword">const</span> <a class="code" href="structCC__Mqtt311SubscribeResponse.html">CC_Mqtt311SubscribeResponse</a>* response)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ERROR: The subscription operation has failed with status=%d\n&quot;</span>, status);</div>
<div class="line">        ... <span class="comment">// handle error.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;response&quot; is not NULL when status is CC_Mqtt311AsyncOpStatus_Complete.</span></div>
<div class="line">    assert(response != NULL);</div>
<div class="line">    ... <span class="comment">// Analyze response values.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__subscribe.html#gaf20fda15c5c5d1f334f285a9c432cfd1">cc_mqtt311_client_subscribe_send</a>(subscribe, &amp;my_subscribe_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send subscribe request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__subscribe_html_gaf20fda15c5c5d1f334f285a9c432cfd1"><div class="ttname"><a href="group__subscribe.html#gaf20fda15c5c5d1f334f285a9c432cfd1">cc_mqtt311_client_subscribe_send</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_subscribe_send(CC_Mqtt311SubscribeHandle handle, CC_Mqtt311SubscribeCompleteCb cb, void *cbData)</div><div class="ttdoc">Send the configured &quot;subscribe&quot; operation to broker.</div></div>
<div class="ttc" id="astructCC__Mqtt311SubscribeResponse_html"><div class="ttname"><a href="structCC__Mqtt311SubscribeResponse.html">CC_Mqtt311SubscribeResponse</a></div><div class="ttdoc">Response information from broker to &quot;subscribe&quot; request.</div><div class="ttdef"><b>Definition:</b> common.h:229</div></div>
</div><!-- fragment --><p> The provided callback will be invoked when the "subscribe" operation is complete <b> if and only if</b> the function returns <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>.</p>
<p>The handle returned by the <b><a class="el" href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d" title="Prepare &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_prepare()</a></b> function can be discarded (there is no free / de-allocation) right after the <b><a class="el" href="group__subscribe.html#gaf20fda15c5c5d1f334f285a9c432cfd1" title="Send the configured &quot;subscribe&quot; operation to broker.">cc_mqtt311_client_subscribe_send()</a></b> invocation regardless of the returned error code. However, the handle remains valid until the callback is called (in case the <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a> was returned). The valid handle can be used to <a class="el" href="index.html#doc_cc_mqtt311_client_subscribe_cancel">cancel</a> the operation before the completion callback is invoked.</p>
<p>Note that the callback function receives the "subscribe" operation handle as its second parameter. Although the handle is already invalid and cannot be used in any other function, it allows the application to identify the original "subscribe" request if multiple have been issued in parallel and use the same callback function for all of them.</p>
<p>When the "subscribe" operation completion callback is invoked the reported "response" information is present <b>if and only if</b> the "status" is <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_cancel"></a>
Cancel the "Subscribe" Operation.</h2>
<p>While the handle returned by the <b><a class="el" href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d" title="Prepare &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_prepare()</a></b> is still valid it is possible to cancel / discard the operation. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__subscribe.html#gadc4735923d847b8cae001f7fdcb2b7ec">cc_mqtt311_client_subscribe_cancel</a>(subscribe);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to cancel subscribe with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__subscribe_html_gadc4735923d847b8cae001f7fdcb2b7ec"><div class="ttname"><a href="group__subscribe.html#gadc4735923d847b8cae001f7fdcb2b7ec">cc_mqtt311_client_subscribe_cancel</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_subscribe_cancel(CC_Mqtt311SubscribeHandle handle)</div><div class="ttdoc">Cancel the allocated &quot;subscribe&quot; operation.</div></div>
</div><!-- fragment --><p> In case the <b><a class="el" href="group__subscribe.html#gaf20fda15c5c5d1f334f285a9c432cfd1" title="Send the configured &quot;subscribe&quot; operation to broker.">cc_mqtt311_client_subscribe_send()</a></b> function was successfully called before the <b><a class="el" href="group__subscribe.html#gadc4735923d847b8cae001f7fdcb2b7ec" title="Cancel the allocated &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_cancel()</a></b>, the operation is cancelled <b>without</b> callback invocation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_subscribe_simplify"></a>
Simplifying the "Subscribe" Operation Preparation.</h2>
<p>In many use cases the "subscribe" operation can be quite simple with a lot of defaults. To simplify the sequence of the operation preparation and handling of errors, the library provides wrapper function that can be used: </p><ul>
<li><b><a class="el" href="group__subscribe.html#gab9c7c40c28ecf751090c92f0b30c1ae4" title="Prepare, configure, and send &quot;subscribe&quot; request in one go.">cc_mqtt311_client_subscribe()</a></b> </li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311SubscribeTopicConfig.html">CC_Mqtt311SubscribeTopicConfig</a> topicConfig;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__subscribe.html#gad0fa342ea2d809b317b805ffa90f675e">cc_mqtt311_client_subscribe_init_config_topic</a>(&amp;topicConfig);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values if needed</span></div>
<div class="line">topicConfig.<a class="code" href="structCC__Mqtt311SubscribeTopicConfig.html#abdb3eb5f4d614cfa813262c0cd59e004">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__subscribe.html#gab9c7c40c28ecf751090c92f0b30c1ae4">cc_mqtt311_client_subscribe</a>(client, &amp;topicConfig, 1, &amp;my_subscribe_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send subscribe request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__subscribe_html_gab9c7c40c28ecf751090c92f0b30c1ae4"><div class="ttname"><a href="group__subscribe.html#gab9c7c40c28ecf751090c92f0b30c1ae4">cc_mqtt311_client_subscribe</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_subscribe(CC_Mqtt311ClientHandle handle, const CC_Mqtt311SubscribeTopicConfig *topicConfigs, unsigned topicConfigsCount, CC_Mqtt311SubscribeCompleteCb cb, void *cbData)</div><div class="ttdoc">Prepare, configure, and send &quot;subscribe&quot; request in one go.</div></div>
</div><!-- fragment --><p> Note that the wrapper function does NOT expose the handle returned by the <b><a class="el" href="group__subscribe.html#ga66977be976fb7fc711b249e0f5b8035d" title="Prepare &quot;subscribe&quot; operation.">cc_mqtt311_client_subscribe_prepare()</a></b>. It means that it's not possible to cancel the "subscribe" operation before its completion or identify the subscribe operation by the reported handle when the completion callback is invoked.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe"></a>
Unsubscribing from Message Reception</h1>
<p>To unsubscribe from receiving incoming messages use <a class="el" href="group__unsubscribe.html">unsubscribe</a> operation. The application can issue multiple "unsubscribe" operations in parallel.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_prepare"></a>
Preparing "Unsubscribe" Operation.</h2>
<div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__unsubscribe.html#ga2b8c62694a5e29a78a70eff052cef026">CC_Mqtt311UnsubscribeHandle</a> unsubscribe = <a class="code" href="group__unsubscribe.html#gaaae59e153bdfaa458055fdce1ec0c111">cc_mqtt311_client_unsubscribe_prepare</a>(client, &amp;ec);</div>
<div class="line"><span class="keywordflow">if</span> (unsubscribe == NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Unsubscribe allocation failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_ga2b8c62694a5e29a78a70eff052cef026"><div class="ttname"><a href="group__unsubscribe.html#ga2b8c62694a5e29a78a70eff052cef026">CC_Mqtt311UnsubscribeHandle</a></div><div class="ttdeci">CC_Mqtt311Unsubscribe * CC_Mqtt311UnsubscribeHandle</div><div class="ttdoc">Handle for &quot;unsubscribe&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:168</div></div>
<div class="ttc" id="agroup__unsubscribe_html_gaaae59e153bdfaa458055fdce1ec0c111"><div class="ttname"><a href="group__unsubscribe.html#gaaae59e153bdfaa458055fdce1ec0c111">cc_mqtt311_client_unsubscribe_prepare</a></div><div class="ttdeci">CC_Mqtt311UnsubscribeHandle cc_mqtt311_client_unsubscribe_prepare(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorCode *ec)</div><div class="ttdoc">Prepare &quot;unsubscribe&quot; operation.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_response_timeout"></a>
Configuring "Unsubscribe" Response Timeout</h2>
<p>When created, the "unsubscribe" operation inherits the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a> configuration. It can be changed for the allocated operation using the <b><a class="el" href="group__unsubscribe.html#ga212ccb1603e5dd4567581e71896218ca" title="Configure the broker response timeout for the &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_set_response_timeout()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__unsubscribe.html#ga212ccb1603e5dd4567581e71896218ca">cc_mqtt311_client_unsubscribe_set_response_timeout</a>(unsubscribe, 1000);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_ga212ccb1603e5dd4567581e71896218ca"><div class="ttname"><a href="group__unsubscribe.html#ga212ccb1603e5dd4567581e71896218ca">cc_mqtt311_client_unsubscribe_set_response_timeout</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_unsubscribe_set_response_timeout(CC_Mqtt311UnsubscribeHandle handle, unsigned ms)</div><div class="ttdoc">Configure the broker response timeout for the &quot;unsubscribe&quot; operation.</div></div>
</div><!-- fragment --><p> To retrieve the configured response timeout use the <b><a class="el" href="group__unsubscribe.html#ga81a6240244ef2ca4d4749f1628badef6" title="Retrieve the configured the broker response timeout for the &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_get_response_timeout()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_topic"></a>
Topic Configuration</h2>
<p>Single <b>UNSUBSCRIBE</b> message can carry multiple topic unsubscriptions. Use <b><a class="el" href="group__unsubscribe.html#ga542fc505d334e3ab88e47323b5fdbbcf" title="Add topic configuration of the &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_config_topic()</a></b> function to configure each such unsubscription. </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a> topicConfig;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__unsubscribe.html#ga39014f617dd9be77ae35a3bff4a0c533">cc_mqtt311_client_unsubscribe_init_config_topic</a>(&amp;topicConfig);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values</span></div>
<div class="line">topicConfig.<a class="code" href="structCC__Mqtt311UnsubscribeTopicConfig.html#aad06e9d1c73b7ce5d468d8b067cb7533">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform the configuration</span></div>
<div class="line">ec = <a class="code" href="group__unsubscribe.html#ga542fc505d334e3ab88e47323b5fdbbcf">cc_mqtt311_client_unsubscribe_config_topic</a>(unsubscribe, &amp;topicConfig);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Topic configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_ga39014f617dd9be77ae35a3bff4a0c533"><div class="ttname"><a href="group__unsubscribe.html#ga39014f617dd9be77ae35a3bff4a0c533">cc_mqtt311_client_unsubscribe_init_config_topic</a></div><div class="ttdeci">void cc_mqtt311_client_unsubscribe_init_config_topic(CC_Mqtt311UnsubscribeTopicConfig *config)</div><div class="ttdoc">Intialize the CC_Mqtt311UnsubscribeTopicConfig configuration structure.</div></div>
<div class="ttc" id="agroup__unsubscribe_html_ga542fc505d334e3ab88e47323b5fdbbcf"><div class="ttname"><a href="group__unsubscribe.html#ga542fc505d334e3ab88e47323b5fdbbcf">cc_mqtt311_client_unsubscribe_config_topic</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_unsubscribe_config_topic(CC_Mqtt311UnsubscribeHandle handle, const CC_Mqtt311UnsubscribeTopicConfig *config)</div><div class="ttdoc">Add topic configuration of the &quot;unsubscribe&quot; operation.</div></div>
<div class="ttc" id="astructCC__Mqtt311UnsubscribeTopicConfig_html"><div class="ttname"><a href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a></div><div class="ttdoc">Topic filter configuration structure of the &quot;unsubscribe&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:238</div></div>
<div class="ttc" id="astructCC__Mqtt311UnsubscribeTopicConfig_html_aad06e9d1c73b7ce5d468d8b067cb7533"><div class="ttname"><a href="structCC__Mqtt311UnsubscribeTopicConfig.html#aad06e9d1c73b7ce5d468d8b067cb7533">CC_Mqtt311UnsubscribeTopicConfig::m_topic</a></div><div class="ttdeci">const char * m_topic</div><div class="ttdoc">&quot;Topic Filter&quot; string, mustn't be NULL</div><div class="ttdef"><b>Definition:</b> common.h:239</div></div>
</div><!-- fragment --><p> See also documentation of the <a class="el" href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a> structure.</p>
<p><b>Note</b> that explicitly initializing the <a class="el" href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a> configuration object is not really necessary, because it has only a single <a class="el" href="structCC__Mqtt311UnsubscribeTopicConfig.html#aad06e9d1c73b7ce5d468d8b067cb7533">CC_Mqtt311UnsubscribeTopicConfig::m_topic</a> member, which is going to be overwritten as part of the configuration. However, calling the <b><a class="el" href="group__unsubscribe.html#ga39014f617dd9be77ae35a3bff4a0c533" title="Intialize the CC_Mqtt311UnsubscribeTopicConfig configuration structure.">cc_mqtt311_client_unsubscribe_init_config_topic()</a></b> is still recommended to make the application's code future updates proof. Potentially the MQTT v3.1.1 specification and as the result this library can be updated by adding new fields to the <a class="el" href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a> struct. Having the "unnecessary" call to the <b><a class="el" href="group__unsubscribe.html#ga39014f617dd9be77ae35a3bff4a0c533" title="Intialize the CC_Mqtt311UnsubscribeTopicConfig configuration structure.">cc_mqtt311_client_unsubscribe_init_config_topic()</a></b> function makes sure that newly added field gets initialized to the default value without any need to update the application's code.</p>
<p>By default the library will perform the analysis of the submitted topic format and reject it if topic format is incorrect. However, for performance reasons it is possible to disable such verification when client application ensures that no invalid topics are used. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__client.html#ga5860ac24216d0adb966db2367ae31690">cc_mqtt311_client_set_verify_outgoing_topic_enabled</a>(client, <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something is wrong */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b> that the configuration is global per client and not per "unsubscribe" operation.</p>
<p>Also <b>note</b> that the same function controls the verification of the "subscribe", "unsubscribe" and "publish" topic formats.</p>
<p>To retrieve the current configuration use <b><a class="el" href="group__client.html#gae0f7745560288d4c6e5dc948289d8a85" title="Retrieve current outgoing topic format verification control.">cc_mqtt311_client_get_verify_outgoing_topic_enabled()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_send"></a>
Sending Unsubscription Request</h2>
<p>When all the necessary configurations are performed for the allocated "unsubscribe" operation it can actually be sent to the broker. To initiate sending use the <b><a class="el" href="group__unsubscribe.html#gaff704015ff227e667a6b71e3e03cfdf0" title="Send the configured &quot;unsubscribe&quot; operation to broker.">cc_mqtt311_client_unsubscribe_send()</a></b> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_unsubscribe_complete_cb(<span class="keywordtype">void</span>* data, <a class="code" href="group__unsubscribe.html#ga2b8c62694a5e29a78a70eff052cef026">CC_Mqtt311UnsubscribeHandle</a> handle, <a class="code" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ERROR: The unsubscription operation has failed with status=%d\n&quot;</span>, status);</div>
<div class="line">        ... <span class="comment">// handle error.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__unsubscribe.html#gaff704015ff227e667a6b71e3e03cfdf0">cc_mqtt311_client_unsubscribe_send</a>(unsubscribe, &amp;my_unsubscribe_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send unsubscribe request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_gaff704015ff227e667a6b71e3e03cfdf0"><div class="ttname"><a href="group__unsubscribe.html#gaff704015ff227e667a6b71e3e03cfdf0">cc_mqtt311_client_unsubscribe_send</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_unsubscribe_send(CC_Mqtt311UnsubscribeHandle handle, CC_Mqtt311UnsubscribeCompleteCb cb, void *cbData)</div><div class="ttdoc">Send the configured &quot;unsubscribe&quot; operation to broker.</div></div>
</div><!-- fragment --><p> The provided callback will be invoked when the "unsubscribe" operation is complete <b> if and only if</b> the function returns <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>.</p>
<p>The handle returned by the <b><a class="el" href="group__unsubscribe.html#gaaae59e153bdfaa458055fdce1ec0c111" title="Prepare &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_prepare()</a></b> function can be discarded (there is no free / de-allocation) right after the <b><a class="el" href="group__unsubscribe.html#gaff704015ff227e667a6b71e3e03cfdf0" title="Send the configured &quot;unsubscribe&quot; operation to broker.">cc_mqtt311_client_unsubscribe_send()</a></b> invocation regardless of the returned error code. However, the handle remains valid until the callback is called (in case the <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a> was returned). The valid handle can be used to <a class="el" href="index.html#doc_cc_mqtt311_client_unsubscribe_cancel">cancel</a> the operation before the completion callback is invoked.</p>
<p>Note that the callback function receives the "unsubscribe" operation handle as its second parameter. Although the handle is already invalid and cannot be used in any other function, it allows the application to identify the original "unsubscribe" request if multiple have been issued in parallel and use the same callback function for all of them.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_cancel"></a>
Cancel the "Unsubscribe" Operation.</h2>
<p>While the handle returned by the <b><a class="el" href="group__unsubscribe.html#gaaae59e153bdfaa458055fdce1ec0c111" title="Prepare &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_prepare()</a></b> is still valid it is possible to cancel / discard the operation. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__unsubscribe.html#ga1a0f82012f48305d6a0bdcafb9947e2d">cc_mqtt311_client_unsubscribe_cancel</a>(unsubscribe);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to cancel unsubscribe with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_ga1a0f82012f48305d6a0bdcafb9947e2d"><div class="ttname"><a href="group__unsubscribe.html#ga1a0f82012f48305d6a0bdcafb9947e2d">cc_mqtt311_client_unsubscribe_cancel</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_unsubscribe_cancel(CC_Mqtt311UnsubscribeHandle handle)</div><div class="ttdoc">Cancel the allocated &quot;unsubscribe&quot; operation.</div></div>
</div><!-- fragment --><p> In case the <b><a class="el" href="group__unsubscribe.html#gaff704015ff227e667a6b71e3e03cfdf0" title="Send the configured &quot;unsubscribe&quot; operation to broker.">cc_mqtt311_client_unsubscribe_send()</a></b> function was successfully called before the <b><a class="el" href="group__unsubscribe.html#ga1a0f82012f48305d6a0bdcafb9947e2d" title="Cancel the allocated &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_cancel()</a></b>, the operation is cancelled <b>without</b> callback invocation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsubscribe_simplify"></a>
Simplifying the "Unsubscribe" Operation Preparation.</h2>
<p>In many use cases the "unsubscribe" operation can be quite simple with a lot of defaults. To simplify the sequence of the operation preparation and handling of errors, the library provides wrapper function that can be used: </p><ul>
<li><b><a class="el" href="group__unsubscribe.html#gac65c867ff019d7ece59a5255fa322bfb" title="Prepare, configure, and send &quot;unsubscribe&quot; request in one go.">cc_mqtt311_client_unsubscribe()</a></b> </li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311UnsubscribeTopicConfig.html">CC_Mqtt311UnsubscribeTopicConfig</a> topicConfig;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__unsubscribe.html#ga39014f617dd9be77ae35a3bff4a0c533">cc_mqtt311_client_unsubscribe_init_config_topic</a>(&amp;topicConfig);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values</span></div>
<div class="line">topicConfig.<a class="code" href="structCC__Mqtt311UnsubscribeTopicConfig.html#aad06e9d1c73b7ce5d468d8b067cb7533">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__unsubscribe.html#gac65c867ff019d7ece59a5255fa322bfb">cc_mqtt311_client_unsubscribe</a>(client, &amp;topicConfig, 1, &amp;my_unsubscribe_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send unsubscribe request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__unsubscribe_html_gac65c867ff019d7ece59a5255fa322bfb"><div class="ttname"><a href="group__unsubscribe.html#gac65c867ff019d7ece59a5255fa322bfb">cc_mqtt311_client_unsubscribe</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_unsubscribe(CC_Mqtt311ClientHandle handle, const CC_Mqtt311UnsubscribeTopicConfig *topicConfigs, unsigned topicConfigsCount, CC_Mqtt311UnsubscribeCompleteCb cb, void *cbData)</div><div class="ttdoc">Prepare, configure, and send &quot;unsubscribe&quot; request in one go.</div></div>
</div><!-- fragment --><p> Note that the wrapper function does NOT expose the handle returned by the <b><a class="el" href="group__unsubscribe.html#gaaae59e153bdfaa458055fdce1ec0c111" title="Prepare &quot;unsubscribe&quot; operation.">cc_mqtt311_client_unsubscribe_prepare()</a></b>. It means that it's not possible to cancel the "unsubscribe" operation before its completion or identify the unsubscribe operation by the reported handle when the completion callback is invoked.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_publish"></a>
Publishing Messages</h1>
<p>To publish messages to the broker use <a class="el" href="group__publish.html">publish</a> operation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_prepare"></a>
Preparing "Publish" Operation.</h2>
<div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>;</div>
<div class="line"><a class="code" href="group__publish.html#ga346c01b3877837bdaf42e361d9ec5dbb">CC_Mqtt311PublishHandle</a> publish = <a class="code" href="group__publish.html#gac24de66e433d731b6f0b5f79c946a7bb">cc_mqtt311_client_publish_prepare</a>(client, &amp;ec);</div>
<div class="line"><span class="keywordflow">if</span> (publish == NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Publish allocation failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga346c01b3877837bdaf42e361d9ec5dbb"><div class="ttname"><a href="group__publish.html#ga346c01b3877837bdaf42e361d9ec5dbb">CC_Mqtt311PublishHandle</a></div><div class="ttdeci">CC_Mqtt311Publish * CC_Mqtt311PublishHandle</div><div class="ttdoc">Handle for &quot;publish&quot; operation.</div><div class="ttdef"><b>Definition:</b> common.h:177</div></div>
<div class="ttc" id="agroup__publish_html_gac24de66e433d731b6f0b5f79c946a7bb"><div class="ttname"><a href="group__publish.html#gac24de66e433d731b6f0b5f79c946a7bb">cc_mqtt311_client_publish_prepare</a></div><div class="ttdeci">CC_Mqtt311PublishHandle cc_mqtt311_client_publish_prepare(CC_Mqtt311ClientHandle handle, CC_Mqtt311ErrorCode *ec)</div><div class="ttdoc">Prepare &quot;publish&quot; operation.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="doc_cc_mqtt311_client_publish_response_timeout"></a>
Configuring "Publish" Response Timeout</h2>
<p>When publishing messages with QoS value <a class="el" href="group__global.html#gga4973a8b35230b10cfa12781cb0e73127a77361f793e1b6010eba8030e5595cbed">CC_Mqtt311QoS_AtLeastOnceDelivery</a> or above, the response from the broker is expected.</p>
<p>When created, the "publish" operation inherits the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a> configuration. It can be changed for the allocated operation using the <b><a class="el" href="group__publish.html#ga53d9278fcb4b853b473c7e85c1e88f59" title="Configure the broker response timeout for the &quot;publish&quot; operation.">cc_mqtt311_client_publish_set_response_timeout()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__publish.html#ga53d9278fcb4b853b473c7e85c1e88f59">cc_mqtt311_client_publish_set_response_timeout</a>(publish, 1000);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga53d9278fcb4b853b473c7e85c1e88f59"><div class="ttname"><a href="group__publish.html#ga53d9278fcb4b853b473c7e85c1e88f59">cc_mqtt311_client_publish_set_response_timeout</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_set_response_timeout(CC_Mqtt311PublishHandle handle, unsigned ms)</div><div class="ttdoc">Configure the broker response timeout for the &quot;publish&quot; operation.</div></div>
</div><!-- fragment --><p> To retrieve the configured response timeout use the <b><a class="el" href="group__publish.html#ga54cc2ae1fb8c4f02fabb458b94577ae4" title="Retrieve the configured the broker response timeout for the &quot;publish&quot; operation.">cc_mqtt311_client_publish_get_response_timeout()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_resend"></a>
Configuring "Publish" Re-Send Attempts</h2>
<p>The MQTT v3.1.1 specification has a mechanism of insured delivery of the published message to the broker. In the case of not 100% reliable connection the messages can get lost and needs to be re-sent. The default amount of re-sends is <b>2</b>, i.e. when the first send is not acknowledged by the broker, it is tried again with <b>DUP</b> flag is set in the <b>PUBLISH</b> message. When the second attempt is not acknowledged, then the publish operation is terminated with appropriate status report. It is possible to change the default by using <b><a class="el" href="group__publish.html#gafd3ca70547c845afe15ce23355bacd98" title="Configure the amount of attempts to resend &quot;publish&quot; operation until the acknowledgement is received.">cc_mqtt311_client_publish_set_resend_attempts()</a></b> function. The <b>DUP</b> flag will be set in all the re-sent <b>PUBLISH</b> messages. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__publish.html#gafd3ca70547c845afe15ce23355bacd98">cc_mqtt311_client_publish_set_resend_attempts</a>(publish, 3);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something went wrong */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_gafd3ca70547c845afe15ce23355bacd98"><div class="ttname"><a href="group__publish.html#gafd3ca70547c845afe15ce23355bacd98">cc_mqtt311_client_publish_set_resend_attempts</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_set_resend_attempts(CC_Mqtt311PublishHandle handle, unsigned attempts)</div><div class="ttdoc">Configure the amount of attempts to resend &quot;publish&quot; operation until the acknowledgement is received.</div></div>
</div><!-- fragment --><p> To retrieve the configured resend attempts number use the <b><a class="el" href="group__publish.html#ga4e7ce156fe21c4366b9fd38dfd7780c3" title="Retrieve the configured the amount of resend attempts for the &quot;publish&quot; operation.">cc_mqtt311_client_publish_get_resend_attempts()</a></b> function.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_basic"></a>
Configuration of "Publish" Operation</h2>
<div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311PublishConfig.html">CC_Mqtt311PublishConfig</a> config;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the &quot;config&quot;</span></div>
<div class="line"><a class="code" href="group__publish.html#ga59cadc39ce5f9d15d9e9b863bbf7890e">cc_mqtt311_client_publish_init_config</a>(&amp;config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update the required values</span></div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a9f2873b215e685c6300f6b7c7d058d5f">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a295da1a2fe72e9a7a0f8da024c62d531">m_data</a> = &amp;some_buf[0];</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a1e59c4e93b141d86bae2dc4f9c6de62a">m_dataLen</a> = ...;</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a521ee512f3fe2ee439c195d111e526c6">m_qos</a> = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform the configuration</span></div>
<div class="line">ec = <a class="code" href="group__publish.html#ga6aec30db8ccdb3405399af4732b6dbcd">cc_mqtt311_client_publish_config</a>(publish, &amp;config);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga59cadc39ce5f9d15d9e9b863bbf7890e"><div class="ttname"><a href="group__publish.html#ga59cadc39ce5f9d15d9e9b863bbf7890e">cc_mqtt311_client_publish_init_config</a></div><div class="ttdeci">void cc_mqtt311_client_publish_init_config(CC_Mqtt311PublishConfig *config)</div><div class="ttdoc">Intialize the CC_Mqtt311PublishConfig configuration structure.</div></div>
<div class="ttc" id="agroup__publish_html_ga6aec30db8ccdb3405399af4732b6dbcd"><div class="ttname"><a href="group__publish.html#ga6aec30db8ccdb3405399af4732b6dbcd">cc_mqtt311_client_publish_config</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_config(CC_Mqtt311PublishHandle handle, const CC_Mqtt311PublishConfig *config)</div><div class="ttdoc">Perform basic configuration of the &quot;publish&quot; operation.</div></div>
<div class="ttc" id="astructCC__Mqtt311PublishConfig_html"><div class="ttname"><a href="structCC__Mqtt311PublishConfig.html">CC_Mqtt311PublishConfig</a></div><div class="ttdoc">Configuration structure to be passed to the cc_mqtt311_client_publish_config().</div><div class="ttdef"><b>Definition:</b> common.h:257</div></div>
<div class="ttc" id="astructCC__Mqtt311PublishConfig_html_a1e59c4e93b141d86bae2dc4f9c6de62a"><div class="ttname"><a href="structCC__Mqtt311PublishConfig.html#a1e59c4e93b141d86bae2dc4f9c6de62a">CC_Mqtt311PublishConfig::m_dataLen</a></div><div class="ttdeci">unsigned m_dataLen</div><div class="ttdoc">Amount of bytes in the publish data buffer, defaults to 0.</div><div class="ttdef"><b>Definition:</b> common.h:260</div></div>
<div class="ttc" id="astructCC__Mqtt311PublishConfig_html_a295da1a2fe72e9a7a0f8da024c62d531"><div class="ttname"><a href="structCC__Mqtt311PublishConfig.html#a295da1a2fe72e9a7a0f8da024c62d531">CC_Mqtt311PublishConfig::m_data</a></div><div class="ttdeci">const unsigned char * m_data</div><div class="ttdoc">Pointer to publish data buffer, defaults to NULL.</div><div class="ttdef"><b>Definition:</b> common.h:259</div></div>
<div class="ttc" id="astructCC__Mqtt311PublishConfig_html_a521ee512f3fe2ee439c195d111e526c6"><div class="ttname"><a href="structCC__Mqtt311PublishConfig.html#a521ee512f3fe2ee439c195d111e526c6">CC_Mqtt311PublishConfig::m_qos</a></div><div class="ttdeci">CC_Mqtt311QoS m_qos</div><div class="ttdoc">Publish QoS value, defaults to CC_Mqtt311QoS_AtMostOnceDelivery.</div><div class="ttdef"><b>Definition:</b> common.h:261</div></div>
<div class="ttc" id="astructCC__Mqtt311PublishConfig_html_a9f2873b215e685c6300f6b7c7d058d5f"><div class="ttname"><a href="structCC__Mqtt311PublishConfig.html#a9f2873b215e685c6300f6b7c7d058d5f">CC_Mqtt311PublishConfig::m_topic</a></div><div class="ttdeci">const char * m_topic</div><div class="ttdoc">Publish topic, cannot be NULL.</div><div class="ttdef"><b>Definition:</b> common.h:258</div></div>
</div><!-- fragment --><p> See also documentation of the <a class="el" href="structCC__Mqtt311PublishConfig.html">CC_Mqtt311PublishConfig</a> structure.</p>
<p>By default the library will perform the analysis of the submitted topic format and reject it if topic format is incorrect. However, for performance reasons it is possible to disable such verification when client application ensures that no invalid topics are used. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__client.html#ga5860ac24216d0adb966db2367ae31690">cc_mqtt311_client_set_verify_outgoing_topic_enabled</a>(client, <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* Something is wrong */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> To retrieve the current configuration use the <b><a class="el" href="group__client.html#gae0f7745560288d4c6e5dc948289d8a85" title="Retrieve current outgoing topic format verification control.">cc_mqtt311_client_get_verify_outgoing_topic_enabled()</a></b> function.</p>
<p><b>NOTE</b> that the configuration is global per client and not per "publish" operation.</p>
<p>Also <b>note</b> that the same function controls the verification of the "subscribe", "unsubscribe", and "publish" filter / topic formats.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_send"></a>
Sending Publish Request</h2>
<p>When all the necessary configurations are performed for the allocated "publish" operation it can actually be sent to the broker. To initiate sending use the <b><a class="el" href="group__publish.html#ga1c09dfa535a128943e9d35d0e12907da" title="Send the configured &quot;publish&quot; operation to broker.">cc_mqtt311_client_publish_send()</a></b> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_publish_complete_cb(<span class="keywordtype">void</span>* data, <a class="code" href="group__publish.html#ga346c01b3877837bdaf42e361d9ec5dbb">CC_Mqtt311PublishHandle</a> handle, <a class="code" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">CC_Mqtt311AsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda9959e33151216c1fb79a6151a3c4214a">CC_Mqtt311AsyncOpStatus_Complete</a>) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ERROR: The publish operation has failed with status=%d\n&quot;</span>, status);</div>
<div class="line">        ... <span class="comment">// handle error.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__publish.html#ga1c09dfa535a128943e9d35d0e12907da">cc_mqtt311_client_publish_send</a>(publish, &amp;my_publish_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send publish request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga1c09dfa535a128943e9d35d0e12907da"><div class="ttname"><a href="group__publish.html#ga1c09dfa535a128943e9d35d0e12907da">cc_mqtt311_client_publish_send</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_send(CC_Mqtt311PublishHandle handle, CC_Mqtt311PublishCompleteCb cb, void *cbData)</div><div class="ttdoc">Send the configured &quot;publish&quot; operation to broker.</div></div>
</div><!-- fragment --><p> The provided callback will be invoked when the "publish" operation is complete <b> if and only if</b> the function returns <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>.</p>
<p>The callback pointer can also be <b>NULL</b>. In such case the completion of the publish operation is silent.</p>
<p>When QoS value is <a class="el" href="group__global.html#gga4973a8b35230b10cfa12781cb0e73127a20167ee83a86a9670adbccd138c80aa0">CC_Mqtt311QoS_AtMostOnceDelivery</a>, there is no broker response to wait for and the callback is invoked right away after sending the serialized data.</p>
<p>The handle returned by the <b><a class="el" href="group__publish.html#gac24de66e433d731b6f0b5f79c946a7bb" title="Prepare &quot;publish&quot; operation.">cc_mqtt311_client_publish_prepare()</a></b> function can be discarded (there is no free / de-allocation) right after the <b><a class="el" href="group__publish.html#ga1c09dfa535a128943e9d35d0e12907da" title="Send the configured &quot;publish&quot; operation to broker.">cc_mqtt311_client_publish_send()</a></b> invocation regardless of the returned error code. However, the handle remains valid until the callback is called (in case the <a class="el" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a> was returned). The valid handle can be used to <a class="el" href="index.html#doc_cc_mqtt311_client_publish_cancel">cancel</a> the operation before the completion callback is invoked.</p>
<p>Note that the callback function receives the "publish" operation handle as its second parameter. Although the handle is already invalid and cannot be used in any other function, it allows the application to identify the original "publish" request if multiple have been issued in parallel and use the same callback function for all of them.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_cancel"></a>
Cancel the "Publish" Operation.</h2>
<p>While the handle returned by the <b><a class="el" href="group__publish.html#gac24de66e433d731b6f0b5f79c946a7bb" title="Prepare &quot;publish&quot; operation.">cc_mqtt311_client_publish_prepare()</a></b> is still valid it is possible to cancel / discard the operation. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__publish.html#gacbac6c0feb39c470d73036b87d8a6c52">cc_mqtt311_client_publish_cancel</a>(publish);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to cancel publish with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_gacbac6c0feb39c470d73036b87d8a6c52"><div class="ttname"><a href="group__publish.html#gacbac6c0feb39c470d73036b87d8a6c52">cc_mqtt311_client_publish_cancel</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_cancel(CC_Mqtt311PublishHandle handle)</div><div class="ttdoc">Cancel the allocated &quot;publish&quot; operation.</div></div>
</div><!-- fragment --><p> In case the <b><a class="el" href="group__publish.html#ga1c09dfa535a128943e9d35d0e12907da" title="Send the configured &quot;publish&quot; operation to broker.">cc_mqtt311_client_publish_send()</a></b> function was successfully called before the <b><a class="el" href="group__publish.html#gacbac6c0feb39c470d73036b87d8a6c52" title="Cancel the allocated &quot;publish&quot; operation.">cc_mqtt311_client_publish_cancel()</a></b>, the operation is cancelled <b>without</b> callback invocation.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_order"></a>
Message Ordering</h2>
<p>The library implements strict message ordering for the <b>same</b> QoS messages required by the MQTT v3.1.1 specification. However, when <b>different</b> QoS messages are sent, the messages may arrive to the broker as well as recipient client in different order. For example, if all the publishes below issued together in the specified order, the <b>Message2</b> and <b>Message3</b> will probably arrive before <b>Message1</b>. </p><ul>
<li><b>Message1</b> - QoS2 </li>
<li><b>Message2</b> - Qos1 </li>
<li><b>Message3</b> - QoS0</li>
</ul>
<p>The library also provides an ability to force strict message ordering for <b>all</b> values of QoS using the <b><a class="el" href="group__publish.html#ga646b2734f8a7b21e63ff06d58a927c86" title="Configure the ordering of the published messages.">cc_mqtt311_client_publish_set_ordering()</a></b> function. </p><div class="fragment"><div class="line">ec = <a class="code" href="group__publish.html#ga646b2734f8a7b21e63ff06d58a927c86">cc_mqtt311_client_publish_set_ordering</a>(client, <a class="code" href="group__publish.html#ggae6a0c339cc547d5fe2db2be5ad8ad60ca88b965f16f0b2440d8efa827a30b3a3d">CC_Mqtt311PublishOrdering_Full</a>);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Publish ordering configuration failed with ec=%d\n&quot;</span>, ec);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga646b2734f8a7b21e63ff06d58a927c86"><div class="ttname"><a href="group__publish.html#ga646b2734f8a7b21e63ff06d58a927c86">cc_mqtt311_client_publish_set_ordering</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish_set_ordering(CC_Mqtt311ClientHandle handle, CC_Mqtt311PublishOrdering ordering)</div><div class="ttdoc">Configure the ordering of the published messages.</div></div>
<div class="ttc" id="agroup__publish_html_ggae6a0c339cc547d5fe2db2be5ad8ad60ca88b965f16f0b2440d8efa827a30b3a3d"><div class="ttname"><a href="group__publish.html#ggae6a0c339cc547d5fe2db2be5ad8ad60ca88b965f16f0b2440d8efa827a30b3a3d">CC_Mqtt311PublishOrdering_Full</a></div><div class="ttdeci">@ CC_Mqtt311PublishOrdering_Full</div><div class="ttdoc">Preserve strict order between all messages.</div><div class="ttdef"><b>Definition:</b> common.h:93</div></div>
</div><!-- fragment --><p> The current configuration can be retrieved using <b><a class="el" href="group__publish.html#ga4e0143a44359321bae8787bbb1c77953" title="Retrieve the configured the publish operations ordering.">cc_mqtt311_client_publish_get_ordering()</a></b> function. The <b>default</b> publish ordering is <a class="el" href="group__publish.html#ggae6a0c339cc547d5fe2db2be5ad8ad60cae694de6c9acb39d22f2400e9467ac624">CC_Mqtt311PublishOrdering_SameQos</a>.</p>
<p>When a strict message ordering for <b>all</b> the messages is enabled (by setting <a class="el" href="group__publish.html#ggae6a0c339cc547d5fe2db2be5ad8ad60ca88b965f16f0b2440d8efa827a30b3a3d">CC_Mqtt311PublishOrdering_Full</a>), The <b>PUBLISH</b> message is postponed if <b>any</b> of the statements below are true: </p><ul>
<li>There are other postponed <b>PUBLISH</b> messages of previously issued "publish" operations. </li>
<li>There are previously issued and incomplete "publish" operation of <b>higher</b> QoS value.</li>
</ul>
<p>The rules above allow sending the same as well as increasing QoS messages in parallel. For example, if all the publishes below issued together in the specified order, the <b>Message11</b> and <b>Message12</b> will be sent, while <b>Message13</b> and <b>Message14</b> are postponed until the delivery of the <b>Message12</b> is complete. </p><ul>
<li><b>Message11</b> - QoS1 </li>
<li><b>Message12</b> - Qos2 </li>
<li><b>Message13</b> - QoS0 </li>
<li><b>Message14</b> - QoS2</li>
</ul>
<p>To inquire whether the <b>PUBLISH</b> message was actually sent, the <b><a class="el" href="group__publish.html#gadcaa9b86ad35f37cf5dbd0f87d817ae4" title="Check whether the &quot;publish&quot; operation was actually initiated (PUBLISH was sent)">cc_mqtt311_client_publish_was_initiated()</a></b> function can be used. If the function returns false, the "publish" operation can be safely <a class="el" href="index.html#doc_cc_mqtt311_client_publish_cancel">cancelled</a> without any possible side effects.</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_publish_simplify"></a>
Simplifying the "Publish" Operation Preparation.</h2>
<p>In many use cases the "publish" operation can be quite simple with a lot of defaults. To simplify the sequence of the operation preparation and handling of errors, the library provides wrapper function that can be used: </p><ul>
<li><b><a class="el" href="group__publish.html#ga1f4342bbaaa1b70a1093844cff0bafaa" title="Prepare, configure, and send &quot;publish&quot; request in one go.">cc_mqtt311_client_publish()</a></b> </li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="structCC__Mqtt311PublishConfig.html">CC_Mqtt311PublishConfig</a> config;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign default values to the configuration</span></div>
<div class="line"><a class="code" href="group__publish.html#ga59cadc39ce5f9d15d9e9b863bbf7890e">cc_mqtt311_client_publish_init_config</a>(&amp;config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update values</span></div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a9f2873b215e685c6300f6b7c7d058d5f">m_topic</a> = <span class="stringliteral">&quot;some/topic&quot;</span>;</div>
<div class="line">config.<a class="code" href="structCC__Mqtt311PublishConfig.html#a295da1a2fe72e9a7a0f8da024c62d531">m_data</a> = ...;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ec = <a class="code" href="group__publish.html#ga1f4342bbaaa1b70a1093844cff0bafaa">cc_mqtt311_client_publish</a>(client, &amp;config, &amp;my_publish_complete_cb, data);</div>
<div class="line"><span class="keywordflow">if</span> (ec != <a class="code" href="group__global.html#gga1313593e8ce828061e8d32ae56c23d4ea3dac801d062eb0672aad9e4a69d52437">CC_Mqtt311ErrorCode_Success</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: Failed to send publish request with ec=%d\n&quot;</span>, ec);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__publish_html_ga1f4342bbaaa1b70a1093844cff0bafaa"><div class="ttname"><a href="group__publish.html#ga1f4342bbaaa1b70a1093844cff0bafaa">cc_mqtt311_client_publish</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_publish(CC_Mqtt311ClientHandle handle, const CC_Mqtt311PublishConfig *config, CC_Mqtt311PublishCompleteCb cb, void *cbData)</div><div class="ttdoc">Prepare, configure, and send &quot;publish&quot; request in one go.</div></div>
</div><!-- fragment --><p> Note that the wrapper function does NOT expose the handle returned by the <b><a class="el" href="group__publish.html#gac24de66e433d731b6f0b5f79c946a7bb" title="Prepare &quot;publish&quot; operation.">cc_mqtt311_client_publish_prepare()</a></b>. It means that it's not possible to cancel the "publish" operation before its completion or identify the publish operation by the reported handle when the completion callback is invoked.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_receive"></a>
Receiving Messages</h1>
<p>Right after the successful "connect" operation, the library starts expecting the arrival of the new messages and reports it via the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_message">registered callback</a>. <b>By default</b> the library monitors the topics the client application <a class="el" href="index.html#doc_cc_mqtt311_client_subscribe">subscribed</a> to and does not report "rogue" messages from the broker.</p>
<p><b>Note</b> that only topics themselves are monitored, and not the requested maximal <b>QoS</b> values. It means that if application requested maximal <b>QoS1</b> for a particular subscription, but the broker sends message using the <b>QoS2</b>, the message is still going to be reported to the application.</p>
<p>However, if the broker is trusted to do the right thing, i.e. fully comply to the specification, it is possible to enable / disable the incoming topics check using the <b><a class="el" href="group__client.html#ga6108d6b72c37b945ba47c89302cb2eed" title="Control verification of the incoming message being correctly subscribed.">cc_mqtt311_client_set_verify_incoming_msg_subscribed()</a></b> for performance reasons. </p><div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__client.html#ga6108d6b72c37b945ba47c89302cb2eed">cc_mqtt311_client_set_verify_incoming_msg_subscribed</a>(client, <span class="keyword">false</span>);</div>
<div class="ttc" id="agroup__client_html_ga6108d6b72c37b945ba47c89302cb2eed"><div class="ttname"><a href="group__client.html#ga6108d6b72c37b945ba47c89302cb2eed">cc_mqtt311_client_set_verify_incoming_msg_subscribed</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_set_verify_incoming_msg_subscribed(CC_Mqtt311ClientHandle handle, bool enabled)</div><div class="ttdoc">Control verification of the incoming message being correctly subscribed.</div></div>
</div><!-- fragment --><p> To retrieve the current configuration use the <b><a class="el" href="group__client.html#ga273e83a6aa88feec9573958862685626" title="Retrieve current incoming message being correctly subscribed control.">cc_mqtt311_client_get_verify_incoming_msg_subscribed()</a></b> function.</p>
<p><b>WARNING:</b> When the incoming message subscription verification is disabled, the library does <b>NOT</b> track any new <a class="el" href="index.html#doc_cc_mqtt311_client_subscribe">subscription</a> requests, which can result in dropping legit messages and not reporting them to the application after the subscription verification is re-enabled later.</p>
<p>Similarly, the library also <b>by default</b> verifies the incoming topic format, that it doesn't contain wildcard characters. To enable / disable such verification use the <b><a class="el" href="group__client.html#ga8e91f41d384c53edbc04c53a06f033d1" title="Control incoming topic format verification.">cc_mqtt311_client_set_verify_incoming_topic_enabled()</a></b> function. </p><div class="fragment"><div class="line"><a class="code" href="group__global.html#ga1313593e8ce828061e8d32ae56c23d4e">CC_Mqtt311ErrorCode</a> ec = <a class="code" href="group__client.html#ga8e91f41d384c53edbc04c53a06f033d1">cc_mqtt311_client_set_verify_incoming_topic_enabled</a>(client, <span class="keyword">false</span>);</div>
<div class="ttc" id="agroup__client_html_ga8e91f41d384c53edbc04c53a06f033d1"><div class="ttname"><a href="group__client.html#ga8e91f41d384c53edbc04c53a06f033d1">cc_mqtt311_client_set_verify_incoming_topic_enabled</a></div><div class="ttdeci">CC_Mqtt311ErrorCode cc_mqtt311_client_set_verify_incoming_topic_enabled(CC_Mqtt311ClientHandle handle, bool enabled)</div><div class="ttdoc">Control incoming topic format verification.</div></div>
</div><!-- fragment --><p> To retrieve the current configuration use the <b><a class="el" href="group__client.html#ga3b448bdb816ce0122216b70eae78da05" title="Retrieve current incoming topic format verification control.">cc_mqtt311_client_get_verify_incoming_topic_enabled()</a></b> function.</p>
<p>To prioritize the in-order reception of the messages, the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_message">message report callback</a> is invoked immediately on reception of the QoS2 <b>PUBLISH</b> message. Just like it is shown as "Method B" in the "Figure 4.3" of the MQTT v3.1.1 specification.</p>
<p>The <b>QoS2</b> publish operation initiated by the broker requires exchange of multiple messages between the broker and the client. When the library responds with the <b>PUBREC</b> message, the broker is expected to send <b>PUBREL</b> back. The library uses the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">Default Response Timeout</a> configuration to measure the time frame during which it allows the reception of the corresponding <b>PUBREL</b> message. If the latter doesn't arrive in time, the inner state of the message reception gets discarded resulting in the future rejection of the relevant <b>PUBREL</b> from the broker (if such arrives). Depending on case whether the <b>PUBREC</b> message was actually received by the broker and how the broker is implemented one of the following scenarios is possible: </p><ul>
<li>The broker has NOT received the <b>PUBREC</b> and will resend its <b>PUBLISH</b> resulting in the duplicate delivery of the message. </li>
<li>The broker has received the <b>PUBREC</b> and according to MQTT v3.1.1 specification it is not allowed to perform <b>PUBLISH</b> again. Th broker might decide to either drop its message delivery state (best case scenario) or treat it as protocol error and disconnect the client.</li>
</ul>
<p>With all said above it might be necessary to increase the <a class="el" href="index.html#doc_cc_mqtt311_client_response_timeout">response timeout</a> for slow networks.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_unsolicited_disconnect"></a>
Unsolicited Broker Disconnection</h1>
<p>When broker disconnection is detected all the incomplete asynchronous operations (except <a class="el" href="index.html#doc_cc_mqtt311_client_publish">publish</a>) will be terminated with the an appropriate <a class="el" href="group__global.html#gaf6bdf774d2591a042326994e6b10c7bd">status</a> report. The incomplete <a class="el" href="index.html#doc_cc_mqtt311_client_publish">publish</a> operations will be preserved due to the following spec clause: </p><div class="fragment"><div class="line">When a Client reconnects with CleanSession set to 0, both the Client and Server MUST re-send any</div>
<div class="line">unacknowledged PUBLISH Packets (where QoS &gt; 0) and PUBREL Packets using their original Packet</div>
<div class="line">Identifiers [MQTT-4.4.0-1].</div>
</div><!-- fragment --><p>The unsolicited broker disconnection can happen in one of the following scenarios:</p>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsolicited_disconnect_keep_alive"></a>
Keep Alive Timeout</h2>
<p>When there was no message from the broker for the "keep alive" timeout (configured during the <a class="el" href="group__connect.html">connect</a> operation) and the broker doesn't respond to the <b>PING</b> message. In such case the library responds in the following way: </p><ul>
<li>Terminates and invokes the callbacks of previously initiated but incomplete operations (except <a class="el" href="index.html#doc_cc_mqtt311_client_publish">publish</a>) passing the <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda814c8d1716ae8c265952fc6a9d67cf74">CC_Mqtt311AsyncOpStatus_BrokerDisconnected</a> as their status report. </li>
<li>Invokes the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">disconnection report callback</a> registered using the <b><a class="el" href="client_8h.html#a17e182fdb5e1288bff8d64e099c69ccb" title="Set callback to report unsolicited disconnection of the broker.">cc_mqtt311_client_set_broker_disconnect_report_callback()</a></b> function reporting <a class="el" href="group__global.html#gga387e5e702bb15bdc7b6aafbfd55237cea6f9e7868b2a7b9c363d91f131eab02e6">CC_Mqtt311BrokerDisconnectReason_NoBrokerResponse</a> as the disconnection reason. without any disconnection information.</li>
</ul>
<h2><a class="anchor" id="doc_cc_mqtt311_client_unsolicited_disconnect_protocol_error"></a>
Detecting Protocol Error</h2>
<p>In case the broker doesn't fully comply with the MQTT v3.1.1 specification or there is some unexpected data corruption the library responds in the following way: </p><ul>
<li>Terminates and invokes the callback of the operation that detected the protocol error with the <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bdad6fcd25f4e1c61d20d9a268dfd1f87da">CC_Mqtt311AsyncOpStatus_ProtocolError</a> status report. </li>
<li>Terminates and invokes the callbacks of all other previously initiated but incomplete operations (except <a class="el" href="index.html#doc_cc_mqtt311_client_publish">publish</a>) passing the <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda814c8d1716ae8c265952fc6a9d67cf74">CC_Mqtt311AsyncOpStatus_BrokerDisconnected</a> as their status report. </li>
<li>Invokes the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">disconnection report callback</a> registered using the <b><a class="el" href="client_8h.html#a17e182fdb5e1288bff8d64e099c69ccb" title="Set callback to report unsolicited disconnection of the broker.">cc_mqtt311_client_set_broker_disconnect_report_callback()</a></b> function reporting <a class="el" href="group__global.html#gga387e5e702bb15bdc7b6aafbfd55237ceaad148b5fd63673444acbb640c35ae9ee">CC_Mqtt311BrokerDisconnectReason_ProtocolError</a> as the disconnection reason. without any disconnection information.</li>
</ul>
<p>With all said above it means that if application receives <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bdad6fcd25f4e1c61d20d9a268dfd1f87da">CC_Mqtt311AsyncOpStatus_ProtocolError</a> or <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda814c8d1716ae8c265952fc6a9d67cf74">CC_Mqtt311AsyncOpStatus_BrokerDisconnected</a> status in the operation callback, then the application is expected to wait for the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">disconnection report callback</a> which will follow.</p>
<p>When the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">disconnection report callback</a> is called the application is expected to go through the following steps: </p><ul>
<li>Close network connection. </li>
<li>Re-establish network connection to the broker. </li>
<li>Perform the <a class="el" href="index.html#doc_cc_mqtt311_client_connect">"connect"</a> operation from within a next event loop iteration.</li>
</ul>
<p>In case the client re-connects to the broker and the broker reports "clean session", then all the incomplete <a class="el" href="index.html#doc_cc_mqtt311_client_publish">publish</a> operations will be terminated with the <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bdaaab67da08f6f6f2a874fdd2622988816">CC_Mqtt311AsyncOpStatus_Aborted</a> status.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_network_disconnect"></a>
Network Disconnection</h1>
<p>In addition to the <a class="el" href="index.html#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a> the network connection can be suddenly terminated. Such network disconnection is usually detected by the failing <b>read</b> or <b>write</b> operations on I/O socket. When the application detects such network disconnection, it is expected to report it to the library using <b><a class="el" href="group__client.html#ga9532341b73dc222ce78456ba126a93b7" title="Report network disconnected.">cc_mqtt311_client_notify_network_disconnected()</a></b> function. </p><div class="fragment"><div class="line"><span class="comment">// Report network disconnected</span></div>
<div class="line"><a class="code" href="group__client.html#ga9532341b73dc222ce78456ba126a93b7">cc_mqtt311_client_notify_network_disconnected</a>(client);</div>
<div class="ttc" id="agroup__client_html_ga9532341b73dc222ce78456ba126a93b7"><div class="ttname"><a href="group__client.html#ga9532341b73dc222ce78456ba126a93b7">cc_mqtt311_client_notify_network_disconnected</a></div><div class="ttdeci">void cc_mqtt311_client_notify_network_disconnected(CC_Mqtt311ClientHandle handle)</div><div class="ttdoc">Report network disconnected.</div></div>
</div><!-- fragment --><p> When the network disconnection is reported, the similar workflow to one described in the <a class="el" href="index.html#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a> section above is performed, <b>excluding</b> the invocation of the <a class="el" href="index.html#doc_cc_mqtt311_client_callbacks_broker_disconnect">broker disconnection report callback</a>. When the incomplete operations get terminated the <a class="el" href="group__global.html#ggaf6bdf774d2591a042326994e6b10c7bda814c8d1716ae8c265952fc6a9d67cf74">CC_Mqtt311AsyncOpStatus_BrokerDisconnected</a> status is reported.</p>
<p>When the <a class="el" href="index.html#doc_cc_mqtt311_client_unsolicited_disconnect">Unsolicited Broker Disconnection</a> is detected prior to the detection of the network disconnection itself and the broker disconnection report callback is invoked, there is <b>no need</b> to report the network disconnection to the library.</p>
<p>Inquiry about current network disconnection status can be done using the <b><a class="el" href="group__client.html#gabbba7a897bb90c497364062cc43fb140" title="Check current network disconnected status.">cc_mqtt311_client_is_network_disconnected()</a></b> function. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> disconnected = <a class="code" href="group__client.html#gabbba7a897bb90c497364062cc43fb140">cc_mqtt311_client_is_network_disconnected</a>(client);</div>
<div class="ttc" id="agroup__client_html_gabbba7a897bb90c497364062cc43fb140"><div class="ttname"><a href="group__client.html#gabbba7a897bb90c497364062cc43fb140">cc_mqtt311_client_is_network_disconnected</a></div><div class="ttdeci">bool cc_mqtt311_client_is_network_disconnected(CC_Mqtt311ClientHandle handle)</div><div class="ttdoc">Check current network disconnected status.</div></div>
</div><!-- fragment --><p> Note that when the new "connect" op is <a class="el" href="index.html#doc_cc_mqtt311_client_connect_prepare">prepared</a>, the library will assume that the network connection is re-established and the subsequent call to the <b><a class="el" href="group__client.html#gabbba7a897bb90c497364062cc43fb140" title="Check current network disconnected status.">cc_mqtt311_client_is_network_disconnected()</a></b> function will return <b>false</b>.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_thread_safety"></a>
Thread Safety</h1>
<p>In general the library is <b>NOT</b> thread safe. To support multi-threading the application is expected to use appropriate locking mechanisms before calling relevant API functions. However, if each thread operates on a separate allocated <a class="el" href="index.html#doc_cc_mqtt311_client_allocation">client</a>, then the locking is required only for the <a class="el" href="index.html#doc_cc_mqtt311_client_allocation">client allocation logic</a>.</p>
<h1><a class="anchor" id="doc_cc_mqtt311_client_debug_build"></a>
Debug Build</h1>
<p>The client library uses <a href="https://commschamp.github.io/comms_doc/page_use_prot.html#page_use_prot_error_handling">COMMS_ASSERT()</a> macro to check some internal pre- and post-conditions. It is a bug if the assertion fails, please report if encountered. By default it is like standard <a href="https://en.cppreference.com/w/cpp/error/assert">assert()</a> but allows overriding the default failure behavour, which can be more suitable for bare-metal systems. Please refer to the <a href="https://commschamp.github.io/comms_doc/page_assert.html">documentation</a> for details. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
